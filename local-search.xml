<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ID3算法原理及实现</title>
    <link href="/2023/05/15/ID3%E7%AE%97%E6%B3%95/"/>
    <url>/2023/05/15/ID3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>ID3算法是一种贪心算法，用来构造决策树。ID3算法起源于概念学习系统（CLS），以信息熵的下降速度为选取测试属性的标准，即在每个节点选取还尚未被用来划分的具有最高信息增益的属性作为划分标准，然后继续这个过程，直到生成的决策树能完美分类训练样例。</p><span id="more"></span><h2 id="ID3算法原理及实现"><a href="#ID3算法原理及实现" class="headerlink" title="ID3算法原理及实现"></a>ID3算法原理及实现</h2><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>ID3算法是一种<strong>分类预测</strong>算法，算法的<strong>核心是“信息熵”</strong>。ID3算法通过计算每个属性的信息增益，认为信息增益高的是好属性，每次划分选取信息增益最高的属性为划分标准，重复这个过程，直至生成一个能完美分类训练样例的决策树。</p><p>决策树是对数据进行分类，以此达到预测的目的。该决策树方法先根据训练集数据形成决策树，如果该树不能对所有对象给出正确的分类，那么选择一些例外加入到训练集数据中，重复该过程一直到形成正确的决策集。决策树代表着决策集的树形结构。</p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树(decision tree)是一类常见的机器学习方法。例如，我们要 对 “这是好瓜吗?”这样的问题进行决策时，通常会进行一系列的判断或“子决策”：我们先看“它是什么颜色?”，如果是 “青绿色”，则我 们再看“它的根蒂是什么形态?”，如果是“蜷缩 ”，我们再判断“它敲起来是什么声音?”，最后，我们得出最终决策：这是个好瓜。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515160908712.png" alt="image-20230515160908712"></p><p>决策过程中提出的每个判定问题都是对某个属性的“测试 ”，每个测试的结果或是导出最终结论，或是导出进一步的判定问题，其考虑范围是在上次决策结果的限定范围之内。决策树学习的目的是为 了产生一棵泛化能力强，即处理未见示例能力强的决策树。</p><h3 id="信息熵和信息增益"><a href="#信息熵和信息增益" class="headerlink" title="信息熵和信息增益"></a>信息熵和信息增益</h3><p>&#x3D;&#x3D;目标：选择最佳分类策略后，整体的信息熵变得最小。&#x3D;&#x3D;</p><p>决策树的关键是如何选择最优划分属性，一般而言，随着划分过程不断进行，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的“纯度”(purity)越来越高。</p><p>经典的 “不纯度”的指标有三种，分别是<strong>信息增益</strong>（ID3 算法）、<strong>信息增益率</strong>（C4.5 算法）以及<strong>基尼指数</strong>（Cart 算法）</p><h4 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h4><p>信息熵是衡量样本集合纯度常用的一种指标，假设当前样本集合D中第$k$类样本所占的比例为$p_k(k&#x3D;1,2,…,|y|)$，则D的信息熵定义为<br>$$<br>Entry(D)&#x3D;-\sum_{k&#x3D;1}^{|y|}p_klog_2\ p_k<br>$$<br><strong>Ent(D)的值越小，则D的纯度越高</strong>；即信息熵越大，不确定性越大。</p><h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p>假设离散属性$a$有$V$个可能的取值${a^1,a^2,…,a^V}$，则如果使用属性$a$来对样本集合D进行分类，会产生$V$个不同的分支，其中第$v$个分支结点包含了D中所有在属性$a$上取值为$a^v$的样本，记为$D^v$，可以根据信息熵的定义计算$D^v$的信息熵，再考虑不同的分支结点包含的样本数不同，给分支结点赋予权重$|D^v|&#x2F;|D|$，于是可以计算<strong>使用属性$a$对样本集进行划分所获得的信息增益</strong>：<br>$$<br>Gain(D,a)&#x3D;Ent(D)-\sum_{v&#x3D;1}^V \frac{|D^v|}{|D|}Ent(D^v)<br>$$<br>一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的“纯度提升”越大。因此，我们可用信息增益来进行决策树的划分属性选择。</p><h3 id="ID3算法流程及实例"><a href="#ID3算法流程及实例" class="headerlink" title="ID3算法流程及实例"></a>ID3算法流程及实例</h3><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>核心思想：在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。</p><p>具体方法：从根结点（root node）开始，对结点计算所有可能的特征信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点；再对子结点递归地调用以上方法，构建决策树；直到所有特征的信息增益均很小或没有特征可以选择。最后得到一个决策树。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>数据集：</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515171543944.png" alt="image-20230515171543944"></p><p>该数据集包含17个训练样例，用以学习一棵能预测没剖开的是不是好瓜的决策树。 在决策树学习开始时，根结点包含D中的所有样例，其中正例占$p_1&#x3D;\frac{8}{17}$，反例占$p_2&#x3D;\frac{9}{17}$，于是，根据定义可计算出根结点的信息熵为<br>$$<br>Ent(D)&#x3D;-\sum_{k&#x3D;1}^2p_k \ log_2\ p_k&#x3D;-(\frac{8}{17}log_2\frac{8}{17}+\frac{9}{17}log_2\frac{9}{17})&#x3D;0.998<br>$$<br>下面计算当前属性集合{色泽，根蒂，敲声，纹理，脐部，触感}中每个属性的信息增益。</p><p>以属性”色泽”为例，它有三个可能的取值{青绿，乌黑，浅白}，如果使用该属性对D进行划分，则可以得到三个子集，记为$D^1$（色泽&#x3D;青绿），$D^2$(色泽&#x3D;乌黑)，$D^3$（色泽&#x3D;浅白）</p><p>子集$D^1$包含的样本共6个，编号为{1,4,6,10,13,17}，其中正例占$p_1&#x3D;\frac{3}{6}$，反例占$p_2&#x3D;\frac{3}{6}$；子集$D^2$包含的样本共6个，编号为{2,3,7,8,9,15}，其中正例占$p_1&#x3D;\frac{4}{6}$，反例占$p_2&#x3D;\frac{2}{6}$；子集$D^3$包含的样本共5个，编号为{5,11,12,14,16}，其中正例占$p_1&#x3D;\frac{1}{5}$，反例占$p_2&#x3D;\frac{4}{5}$；计算出用“色泽”划分之后所获得的 3 个分支结点的信息熵为</p><p>$$<br>Ent(D^1)&#x3D;-(\frac{3}{6}log_2\frac{3}{6}+\frac{3}{6}log_2\frac{3}{6})&#x3D;1.000,<br>$$</p><p>$$<br>Ent(D^2)&#x3D;-(\frac{4}{6}log_2\frac{4}{6}+\frac{2}{6}log_2\frac{2}{6})&#x3D;0.918,<br>$$</p><p>$$<br>Ent(D^3)&#x3D;-(\frac{1}{5}log_2\frac{1}{5}+\frac{4}{5}log_2\frac{4}{5})&#x3D;0.722<br>$$</p><p>因此，计算出属性色泽的信息增益为：<br>$$<br>Gain(D,色泽)&#x3D;Ent(D)-\sum_{v&#x3D;1}^3\frac{|D^v|}{|D|}Ent(D^v)<br>$$</p><p>$$<br>Gain(D,色泽)&#x3D;Ent(D)-\sum_{v&#x3D;1}^3\frac{|D^v|}{|D|}Ent(D^v)<br>$$</p><p>$$<br>&#x3D;0.998- (\frac{6}{17}×1.000+\frac{6}{17}×0.918+\frac{5}{17}×0.722）&#x3D;0.109<br>$$<br>类似的，计算其他属性的信息增益：</p><p>$$ Gain（D,根蒂）&#x3D; 0.143; Gain（D , 敲声）&#x3D; 0.141;  $$$$ \<br>Gain（D ,纹理）&#x3D; 0.381; Gain（D , 脐部）&#x3D; 0.289;$$ $$  \<br>Gain（D ,触感）&#x3D; 0.006.$$</p><p>属性 “纹理”的信息增益最大，于是它被选为划分属性。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515173747632.png" alt="image-20230515173747632"></p><p>然后，决策树学习算法将对每个分支结点做进一步划分。</p><h3 id="ID3算法缺点"><a href="#ID3算法缺点" class="headerlink" title="ID3算法缺点"></a>ID3算法缺点</h3><ul><li>ID3没有剪枝策略，容易过拟合</li><li>信息增益准则对可取值数目较多的特征有所偏好。因为相同条件下，取值比较多的特征的信息增益大于取值较少的特征</li><li>只能用于处理离散分布的特征，没有考虑到特征连续值的情况，即如人的身高、体重都是连续值，无法在ID3算法中应用，即ID3算法更适合做分类</li><li>没有考虑缺失值</li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo+github+typora 图床</title>
    <link href="/2023/05/15/PicGo-github-%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/05/15/PicGo-github-%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p>在日常使用typora过程中，插入图片会将图片保存在本地，图片地址不对（是本地地止），<strong>直接复制到网站上，会导致图片加截不出来</strong>。因此将博客上传到github时，要么需要将图片同md文件同时上传到github，要么需要将图像上传到其他的一些图床上，再将md文件中的图像链接替换成网络地址。之前一直想搞这个事情，但是平时的文章中图片不是很多，<del>就懒得弄（懒死bushi）</del>。</p><p>不过还是想解决掉这个问题，避免以后在上传blog之前还得将图片上传到图床上，因此想利用PicGo搭配typora将图片自动上传到第三方图床上，由于github免费，所以选择它作为第三方图床。</p><ul><li>Typora：文章编辑器</li><li>PicGo：自动上传typora中的图片</li><li>Github：作为第三方图床，存储图片</li><li>CDN：Github在国内访问并不稳定，加速访问</li></ul><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><a href="https://typora.io/">Typora</a>：目前typora已经开始收费了，可以尝试使用历史版本</p><p><a href="https://molunerfinn.com/PicGo/">PicGo</a></p><h2 id="Github-配置"><a href="#Github-配置" class="headerlink" title="Github 配置"></a>Github 配置</h2><ol><li><p>在自己的github中新建一个仓库，用来存储上传的图片 eg：Yank3l&#x2F;ImageHosting</p></li><li><p>点击右上角头像-&gt;Setting-&gt;Developer settings-&gt;Personal access tokens-&gt;tokens(classic)-&gt;生成token</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515105059306.png" alt="image-20230515105059306"></p></li></ol><h2 id="PicGo配置"><a href="#PicGo配置" class="headerlink" title="PicGo配置"></a>PicGo配置</h2><p>我是用的是2.4.0-beta.1版本</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515105335763.png" alt="image-20230515105335763"></p><ul><li>图床配置名：以前的版本好像是没有这个选项的，这里我就随便起了个名字</li><li>设定仓库名：填写自己的github用户名&#x2F;仓库名 例如我的github用户名为yank3l，仓库名为ImageHosting</li><li>设定分支名：填写main，有的教程写的是master，会出现问题，这是因为github创建的仓库默认都是main分支，不是master分支</li><li>设定token：复制github生成的token数据</li><li>设定存储路径：是指在仓库名下会生成一个文件夹，在该文件夹中存储图像</li><li>设定自定义域名：<code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code></li></ul><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><p>在上传图片中可能会出现网络错误，这里设置代理，方便在上传图片时也使用主机的代理，我是用的是<code>clash</code>，其默认是端口号是7890，因此代理地址设置为<code>http://127.0.0.1；7890</code>（PicGo<strong>只支持简单HTTP代理</strong>），插件安装镜像按照官方文档设置为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://registry.npm.taobao.org/<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515111306729.png" alt="image-20230515111306729"></p><h2 id="typora测试"><a href="#typora测试" class="headerlink" title="typora测试"></a>typora测试</h2><p>typora上传服务可以选择app或者命令行，这里选择的是app，完成后点击验证图片上传选项，会显示上传成功，仓库里会上传typora的图标。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515111504157.png" alt="image-20230515111504157"></p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515112256013.png" alt="image-20230515112256013"></p><p>配置过程中可能会出错，可以在PicGo的日志文件中查看错误原因和代码，一般来说错误代码为4xx的一般是配置填写错误。其他原因查看文档以及github的issue</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515112322848.png" alt="image-20230515112322848"></p><p>参考链接</p><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here">PicGo指南</a></p><p><a href="https://github.com/Molunerfinn/PicGo/issues">PicGo-issue</a></p><p><a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md">PicGo常见问题</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
      <tag>github</tag>
      
      <tag>PicGo</tag>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OAuth2.0</title>
    <link href="/2022/07/15/OAuth2-0/"/>
    <url>/2022/07/15/OAuth2-0/</url>
    
    <content type="html"><![CDATA[<h1 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h1><p>OAuth（Open Authorization，开放授权）是一个开放标准的授权协议，允许用户授权第三方应用访问他们存储在资源服务上受保护的信息，而不需要将用户名和密码提供给第三方应用。</p><span id="more"></span><table><tr><td bgcolor=#EAEAEF>文章内容来自阿里云相关介绍，相关链接见文章末尾。</td></tr></table><hr><ul><li><p>OAuth2是用于REST&#x2F;APIs的代理授权框架(delegated authorization framework)</p></li><li><p>OAuth2是基于令牌Token的授权,在无需暴露用户密码的情况下,让应用获取对用户数据有限访问权限</p></li><li><p>OAuth2解耦认证和授权</p></li></ul><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>让朋友去自己家取东西，如果我直接给他门禁系统的密码，朋友就拥有了与我同样的权限，这样不太合适。如果我想取消朋友进入我家的权限，需要更改密码才可以，操作麻烦。</p><p>能不能有种方法，朋友可以进入我家，但是又不知道我家门禁的密码。朋友如果多次进入我家，每次都需要经过我的授权，我不授权的就进不去，我授权后才能进去。</p><p>方案如下：</p><p>第一步，在门禁系统的密码输入器下面，增加一个按钮，比如叫做”获取授权”。朋友需要首先按这个按钮，去申请授权。</p><p>第二步，朋友按下按钮以后，我的手机就会弹出提示：有人正在请求授权，并显示朋友的姓名。我确认情况属实，点击同意授权。</p><p>第三步，门禁系统得到我的确认后，向朋友发送一个进入房屋的令牌（access token），令牌是类似密码的一串数字，只在短期内有效。</p><p>第四步，朋友向门禁系统输入令牌，进入房屋。</p><h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><ul><li><strong>Third-party application</strong>: 第三方应用，又称”客户端”（client），如上面场景中的门禁系统。</li><li><strong>Resource Owner</strong>: 资源拥有者，也就是用户。</li><li><strong>Http Service</strong>: 服务提供商，也就是持有Resource Server的存在方。可以理解为类似微信，钉钉这样具备用户信息的服务者。</li><li><strong>Authorization server</strong>: 认证服务器，即服务提供商专门用来处理认证的服务器。</li><li><strong>Resource server</strong>: 资源服务器，即服务提供商存放用户生成的资源的服务器。与认证服务器是不同的逻辑节点，但是在物理上，双方是可以在一起的</li><li><strong>User Agent</strong>: 用户代理，一般就是指的浏览器。</li><li><strong>客户端凭证</strong>: Client Id和密码用于认证用户。</li><li><strong>访问令牌</strong>: 授权服务提供者在接收到用户请求后,颁发的访问令牌。</li><li><strong>刷新令牌</strong>(Refresh Token): 用于<strong>获取一个新的令牌</strong>。由于令牌的有效期比较短，一旦失效，用户需要再获取令牌的流程是比较繁琐的。为了提升用户体验，可以使用reflesh_token来获取新的令牌。</li></ul><p><strong>举例</strong></p><p>【小明】授权【在线打印app】到【QQ空间】访问【小明的指定相册】，以完成打印工作。</p><p><img src="https://s1.ax1x.com/2023/05/14/p9cHec4.png"></p><h2 id="OAuth应用场景"><a href="#OAuth应用场景" class="headerlink" title="OAuth应用场景"></a>OAuth应用场景</h2><p><strong>开放系统间授权：社交联合登录、开放API平台</strong></p><p>比如：APP或者网页接入一些第三方应用时，时常会需要用户登录另一个合作平台，比如钉钉，QQ，微博的授权登录, 这些平台都提供了基于OAuth2的机制，你可以用这些平台的账号登录而无需在其他网站上进行注册，并授权此网站获取其账号信息，包括用户名、头像等。</p><p><strong>现代微服务安全：单页浏览器App(HTML5&#x2F;JS&#x2F;无状态)、无线原生App</strong></p><p>比如：app登录请求后台接口，为了安全认证，所有请求都带token信息，如果登录验证、请求后台数据。</p><p><strong>企业内部应用认证授权(IAM&#x2F;SSO)，前后端分离单页面应用（spa）</strong></p><p>比如：有个应用是别人开发的，你需要将系统进行整合或者数据对接，此时需要单点登录；前后端分离框架，前端请求后台数据，需要进行oauth2安全认证。</p><h2 id="token-vs-password"><a href="#token-vs-password" class="headerlink" title="token vs password"></a>token vs password</h2><p>（1）<strong>令牌是短期的</strong>，到期会自动失效，用户自己无法修改。<strong>密码一般长期有效</strong>，用户不修改，就不会发生变化。</p><p>（2）<strong>令牌可以被资源持有者撤销，会立即失效</strong>。以上例而言，我可以随时取消朋友的令牌，密码一般不允许被他人撤销。</p><p>（3）<strong>令牌有权限范围</strong>（scope），比如使用令牌只允许进入客厅，不允许进入卧室。对于网络服务来说，只读令牌比读写令牌更安全，而<strong>密码一般是完整权限</strong>。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>协议框架太宽泛,造成各种实现的兼容性和相互操作性差</li><li>和OAuth1.0不兼容</li><li>OAuth2.0<strong>不是一个认证协议(是授权协议)</strong> ,OAuth2.0本身并不能告诉你任何用户信息.</li></ul><h2 id="OAuth2-0-的授权模式"><a href="#OAuth2-0-的授权模式" class="headerlink" title="OAuth2.0 的授权模式"></a>OAuth2.0 的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得访问令牌（access token）。</p><p>OAuth 2.0 规定了四种获得令牌的流程，可以选择实际情况选择最适合的一种，向第三方应用颁发令牌。</p><ul><li><strong>授权码模式（authorization-code）</strong>：正宗方式，支持refresh_token</li><li><strong>简化模式（implicit）</strong>:  为web浏览器应用设计，不支持refresh_token</li><li><strong>密码模式（password）</strong>:  为遗留系统设计，支持refresh_token</li><li><strong>客户端模式（client credentials）</strong>：为后台api服务设计，不支持refresh_token</li></ul><table><thead><tr><th><span style= "display:inline-block;width:100px">授权模式</span></th><th><span style= "display:inline-block;width:80px">优点</span></th><th><span style= "display:inline-block;width:100px">缺点</span></th><th><span style= "display:inline-block;width:100px">备注</span></th></tr></thead><tbody><tr><td>授权码模式</td><td>Access token通过服务器之间进行交换，比较安全</td><td>请求次数比较多</td><td>推荐该模式</td></tr><tr><td>简化模式</td><td>请求次数比较少，简单</td><td>1.没有获取code的过程， Access token直接从授权服务器返回给client客户端，<strong>令牌容易因为被拦截窃听而泄露</strong>                                                                               2.无法存储refresh token，不支持刷新令牌： 要么access token有效性给很长 要么access token过期后，让用户重新认证</td><td>适用于公开的浏览器单页应用</td></tr><tr><td>密码模式</td><td>请求次数比较少，简单</td><td>1.Client会获得用户的登录信息，除非是非常信任的应用，否则可能导致登录信息泄露。                                                                                                                     2.没有多因子认证这样的机制。</td><td>1.可以用来做遗留项目升级OAuth2的适配方案 2.Client是自家应用的场景</td></tr><tr><td>客户端模式</td><td></td><td></td><td></td></tr></tbody></table><p>不管哪一种授权方式，第三方应用<em>申请令牌之前，都必须先到系统备案</em>，说明自己的身份，然后会拿到两个身份识别码：<strong>客户端 ID（client ID  用来标识第三方应用）和客户端密钥（client secret  用来进行安全加密）</strong>。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p>OAuth2最常用的一种授权许可类型，<strong>要求Client具有可公开访问的Server服务器</strong>来接受Authorization Code </p><p>(适合client具备后端服务器的场景。要求client必须能够安全存储密钥,用于后续使用auth code换access token，需要通过浏览器与终端用户交互完成认证授权。通过浏览器重定向将auth code发送到authorization server，换取access token)</p><ul><li>这种模式算是正宗的OAuth2的授权模式</li><li>设计了Auth code，通过这个code再获取token</li><li>支持refresh token</li></ul><p><img src="https://s1.ax1x.com/2023/05/14/p9cHMH1.png"></p><ol><li>用户登录应用系统，请求跳转到认证服务器，并302返回登录认证页面；</li><li>用户输入账户+密码进行认证，认证服务器认证通过返回code给应用系统；</li><li>应用系统携带code向认证服务器换取访问令牌，认证服务器验证Client ID，code等信息，给应用系统发送访问令牌；</li><li>应用系统携带访问令牌查询用户登录信息，认证服务器返回用户信息，如用户名；</li><li>应用系统验证用户名正确，创建会话，并跳转到redirect url。</li></ol><h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>省略掉了颁发授权码（Authorization Code）给客户端的过程，直接返回访问令牌和可选的刷新令牌。<strong>其适用于没有Server服务器来接受处理Authorization Code的第三方应用。</strong> </p><p><img src="https://s1.ax1x.com/2023/05/14/p9cHYge.png"></p><h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>这种模式再一步简化，和Authorzation Code类型下重要的区分就是<strong>省略了Authorization  Request和Authorization Response</strong>。</p><p>而是<strong>Client直接使用Resource  owner提供的username和password来直接请求access_token</strong>（直接发起Access Token  Request然后返回Access Token Response信息）。这种模式一般<strong>适用于Resource  server高度信任第三方Client的情况下。</strong></p><p><img src="https://s1.ax1x.com/2023/05/14/p9cH0Et.png"></p><h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>Client直接已自己的名义而不是Resource owner的名义去要求访问Resource server的一些受保护资源</p><ul><li><strong>适用于服务器间通信场景</strong>，直接根据client的id和密钥即可获取token，无需用户参与</li><li>这种模式比较适合消费api的后端服务，比如拉取一组用户信息等</li><li>不支持refresh token</li></ul><p>Refresh token的初衷主要是为了用户体验不想用户重复输入账号密码来换取新token，因而设计了refresh  token用于换取新token，客户端模式由于没有用户参与，而且也不需要用户账号密码，仅仅根据自己的id和密钥就可以换取新token，因而没必要refresh token.</p><p><img src="https://s1.ax1x.com/2023/05/14/p9cHy8S.png"></p><h2 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h2><p>以便在访问令牌过期失效的时候可以由客户端自动获取新的访问令牌，而不是让用户再次登录授权。</p><p><img src="https://s1.ax1x.com/2023/05/14/p9cHcvQ.png"></p><p>参考链接</p><blockquote><p>[1]<a href="https://developer.aliyun.com/article/808319#slide-2">https://developer.aliyun.com/article/808319#slide-2</a></p><p>[2]<a href="https://help.aliyun.com/document_detail/174227.html">https://help.aliyun.com/document_detail/174227.html</a></p><p>[3]<a href="https://blog.csdn.net/qq_26878363/article/details/115394602">https://blog.csdn.net/qq_26878363/article/details/115394602</a></p><p>[4]<a href="https://blog.csdn.net/luo15242208310/article/details/120223634">https://blog.csdn.net/luo15242208310/article/details/120223634</a></p><p>[5]<a href="https://blog.csdn.net/luo15242208310/article/details/123596841">https://blog.csdn.net/luo15242208310/article/details/123596841</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>SSO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth</tag>
      
      <tag>SSO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Yank3l的2021求学经历</title>
    <link href="/2021/10/10/Yank3l%E7%9A%842021%E6%B1%82%E5%AD%A6%E7%BB%8F%E5%8E%86/"/>
    <url>/2021/10/10/Yank3l%E7%9A%842021%E6%B1%82%E5%AD%A6%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>2021年也是很卷的一年呀，从邻近期末考试开始，复习、报名、面试一直重复，终于9.28一切敲定，这才有时间写个帖子记录一下自己的经历。</p><p>这个夏天的风，注定吹进心里。这段记忆，是一生难忘的回忆。</p><span id="more"></span><h1 id="Yank3l的2021网安求学经历"><a href="#Yank3l的2021网安求学经历" class="headerlink" title="Yank3l的2021网安求学经历"></a>Yank3l的2021网安求学经历</h1><h2 id="本人情况"><a href="#本人情况" class="headerlink" title="本人情况"></a>本人情况</h2><p>本科院校：西安电子科技大学</p><p>学院：网络与信息安全学院</p><p>专业：信息安全</p><p>夏令营排名：6&#x2F;154</p><p>预推免排名：5&#x2F;153</p><p>英语情况：CET4：481、CET6：434（很拉了）</p><p>竞赛情况：数竞省一、信息安全作品赛国三（夏令营时未出、预推免时已出）</p><p>项目经历：与物联网相关的项目（信安赛参赛作品）</p><p>获奖情况：数竞省一、信息安全作品赛国三（夏令营时未出、预推免时已出）还有一些不太重要的奖项</p><p>论文与科研情况：无</p><h2 id="前期准备和复习情况"><a href="#前期准备和复习情况" class="headerlink" title="前期准备和复习情况"></a>前期准备和复习情况</h2><p>仔细想想，自己大概是从7月初开始着手保研相关的事宜的，前期一直说准备，但是也因为其他的事情一直没开始，7月初期末考试结束后才开始复习相关的专业课。7月到8月末期间，一边准备夏令营的事情，一边还在准备信安作品赛的事情（o(╥﹏╥)o）。</p><h3 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h3><p>文书方面的话，我主要准备的夏令营&#x2F;预推免材料有：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">·个人简历<br>·前五学期专业排名证明（带学院教务处盖章）<br>·前五学期成绩单<br>·四六级证书<br>·获奖证书<br>·身份证<br>·学生证<br>·个人陈述（以<span class="hljs-number">1000</span>字为主，还有<span class="hljs-number">800</span>、<span class="hljs-number">1500</span>、<span class="hljs-number">2000</span>字的适当删减或者扩充）<br>·个人介绍PPT<br>·自我介绍（<span class="hljs-number">3</span><span class="hljs-built_in">min</span>、<span class="hljs-number">5</span><span class="hljs-built_in">min</span>，离谱的还有<span class="hljs-number">1</span><span class="hljs-built_in">min</span>）||中英文两版，可能会配合上面的PPT一起<br>·一寸免冠照片电子版（红底或者蓝底应该都行）<br></code></pre></td></tr></table></figure><h3 id="复习方面"><a href="#复习方面" class="headerlink" title="复习方面"></a>复习方面</h3><p>在7月的时候，我主要复习了现代密码学（第四版 杨波）、网络安全基础（黑皮书）、计算机网络（数据通信与网络）、软件与系统安全、信息安全数学基础看了一些（数论+近世代数的知识） 然后就参加了一些夏令营，这个时候复习成这个样子，现在想想确实拉胯。</p><p>7月底的时候，夏令营基本结束了，我也已经打算开始准备预推免了。7月底-8月初，又参加了学院为期两周的实习，又没有复习。之后一直到9月份各个大学预推免开始，复习的已经差不多了。复习了：现代密码学、网络安全基础、信息安全数学基础、计算机网络、操作系统、数据结构、软件与系统安全、线性代数、数据库、离散数学和概率论（只复习了一部分）。</p><h2 id="夏令营和预推免投递情况"><a href="#夏令营和预推免投递情况" class="headerlink" title="夏令营和预推免投递情况"></a>夏令营和预推免投递情况</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gcode">夏令营：（惨重<span class="hljs-comment">(灬ꈍ ꈍ灬)</span>）<br>中科大网安（未入营）<br>西交网安（入营未优营）<br>信工所国重（学硕优营）<br>软件所（未入营）<br>上交网安（未入营）<br>武大网安（入营未优营）<br>东南网安（入营专硕 wl）<br>国防科大计算机学院网安（未入营）<br>国防科大电子对抗学院网安（优营）<br>南大计算机（未入营 未获取笔试资格）<br>复旦网安（未入营）<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">预推免：<br>哈工深计算机（入预推免未通过）<br>中科大网安（学硕offer）<br>软件所（offer）<br>南大（未入）<br>武大网安（入了放弃）<br>北航网安（入了放弃）<br>浙大网安（学硕offer）<br>计算所（入了放弃）<br></code></pre></td></tr></table></figure><p>求学之路也是非常坎坷艰辛了</p><h2 id="夏令营经历"><a href="#夏令营经历" class="headerlink" title="夏令营经历"></a>夏令营经历</h2><p>夏令营投报时主要参考了往年学长学姐的保研去向，但是还是没有想到今年的情况这么卷，旱的旱死，涝的涝死。由于是线上开展（大部分学校）的第二年，所以学生和学校都各自有了经验，学生海学校，学校海学生。今年我参加夏令营时的策略不对，只投报了往年能去的那些学校（而且基本上学院的学生都报了那些学校，学院内就开始竞争了，更别说外校），而没有什么保底的学校（因为卷，所以所有的都应该降低一个等级，保底的也要海投）。看起来我投了很多，但其实过的就那几个，夏令营结束也就两个保底的offer。</p><h3 id="西交网安"><a href="#西交网安" class="headerlink" title="西交网安"></a>西交网安</h3><p>西交网安夏令营应该是开始的最早的了，应该是6月22日面试，我记得那个时候我还在准备期末考试。由于那个时候也没咋复习，就看了看现代密码学，还有网络安全基础（这门课期末要考），然后复习了一下简历上面写的项目（那个时候正在准备信安赛，而且我对我们的项目基本上都了解），还复习了一下之前课程项目的内容，包括原理还有具体步骤之类的。</p><p>面试那天的流程如下</p><p><img src="https://z3.ax1x.com/2021/10/11/5VKXl9.png"></p><p>入营了大概60人左右，分为三组进行面试。我下午等了好久（期间都睡着了），大概快到五点才到我。西交网安的面试每个人大概是8min，5minPPT自我介绍+提问。提问我的问题是与项目相关的一个问题（仅此一个问题），我也回答上来了，然后问了我能不能确定有保研资格，报了哪些夏令营，如果过了来不来交大。我回答了报了武大网安，如果过了西交就去（虽然昧良心，但是脑子还是瓦特了，建议一般这种问题要回答一个比面试学校等级低的学校）。</p><p>总之面试的自我感觉还不错，感觉应该可以拿优营（因为他确实啥都没问），不过考完试那天，大概是7月1日，刚考完拿出手机，就看到微信群里面说官网出结果通知了，激动地下载下来瞅了瞅，刚考完试的心情越发拔凉拔凉了，优营15个，我们院入营面试的人一个也没拿到。本来想着西交网安就是拿来试试水，结果是个这，开始怀疑自己。。。</p><h3 id="信工所国重"><a href="#信工所国重" class="headerlink" title="信工所国重"></a>信工所国重</h3><p>当时报信工所的时候发现材料很麻烦，就没有报，到最后一天才知道那些材料是入营了才交的，趁着最后一天（依稀记得那一天在复习）赶紧报了一下（没想到是拿到的第一个offer）</p><p>信工所入营了以后是要准备官网的那些材料的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">夏令营报名表<br>身份证、学生证<br>考核表<br>政审表（这个比较麻烦 需要负责人签字盖章）<br>成绩单<br>中国科学院大学2022级推免生招生网络远程面试考生诚信承诺书<br>个人简历<br>个人简历<br>其他证明材料（非必要材料）<br></code></pre></td></tr></table></figure><p>入营了之后我就联系了一个老师，老师接着第二天就安排了腾讯会议互相了解（其实就是面试考核），晚上九点开始，大概面试了30min，有3个老师面试，其中有一个是我联系的老师，另外两个是同一个课题组的吧。</p><p>老师面试询问的有项目，密码学，线性代数，网络安全基础，好像还有软件与系统安全（这个忘了），总之感觉整体还行，但是还是有没回答上来的问题，比较慌。之后冒昧地发邮件问了老师我表现得怎么样，老师回邮件说加他微信，然后让等结果。</p><p>信工所的夏令营安排是：夏令营采用线上和线下相结合的形式，7月9日-11日线上入营，7月12日-16日线上活动（含线上面试考核），7月26日-8月优秀营员线下游学活动。</p><p>在面试之前，会让所有的营员选择面试的研究室，有修改志愿的机会，我一直对国重和六室比较有好感，由于六室要进行机试（好像是ctf&#x2F;编程），加上之前联系了国重的老师，就选择了国重，不过喜欢做ai的可以选择二室cyn老师（听说非常nice，不过竞争也很激烈）。</p><p>国重是14号进行网络测试，15-16号进行面试（我是15号下午），面试最难受的是要求双手必须出现在主机位屏幕（挺难弄的）。通知的面试相关信息是：英语口试（5-7min左右）+专业知识及综合素质考察（13-15min左右）。</p><p>国重面试最让我记忆深刻（因为太尴尬了），我回答的问题也不知道对与错，就知道哪些东西说哪些吧，这里想说的是<strong>千万不要把没有复习的科目写在简历上</strong>，这是自己给自己挖坑（就算那门课考的很高）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">英语自我介绍+介绍你的家庭<br>对密码学哪一块感兴趣<br>后面是一堆输出了 有数据结构 操作系统 微机原理<br>！！一点项目相关的问题都没有问<br></code></pre></td></tr></table></figure><p>问我的问题很多是给你一个问题，问你编程如何实现（我记得这里好像与排序相关），然后还问了中断之类的问题（都是我自己挖的坑）。</p><p>面完试我就觉得无了，微信上面问了我联系的老师，老师让我等结果，这个时候我觉得应该是没了，认为老师在婉拒我，因为如果接收的话应该就告诉你了，况且我认为自己在所里面的面试表现的并不好，之后听别的同学说他们问的专业课和项目，我就更觉得无了。</p><p>然后某一天下午，我的竞赛队友和我说信工所优营名单出了，我也没敢问他有没有我，后来去官网看了一下，才知道拿了优营。第二天在微信上问了一下老师，老师说是他接收我了，是学硕。优营名单里面有很多我们学校的，总的数量也挺多的，后来听说还有夏令营第二批。</p><p>我联系的国重老师人也很好，实力也不错，在之后的好长时间都觉得自己应该就去这个老师这里了。9月初还邮寄了信工所推免生要求的体检报告（花了将近300个大洋）。</p><p>不过在拿到中科大offer的时候，我就和这位老师说了情况，老师人也很好。</p><h3 id="武大网安"><a href="#武大网安" class="headerlink" title="武大网安"></a>武大网安</h3><p>武大网安夏令营是线下举办的，提供住宿，并且报销路费（以硬座为标准，需要打印报销凭证），大概就是去的高铁费用吧。夏令营我们学院大概入了10几个好像（我们专业排名卡了7%），不过由于上交网安和武大网安时间冲突，而且两个都是线下的，所以入了上交的同学们都放弃了武大夏令营，最后好像入营150多个人。</p><p>我和我们院的三个小伙伴商量着一起去武汉，在高铁车上还在看数据结构（虽然没看进去）。我们到了武大安排的酒店后，也认识了几个新的小伙伴，后面大家也都在一起玩。下面是武大的夏令营安排。</p><p><img src="C:\Users\yang402\AppData\Roaming\Typora\typora-user-images\image-20211011112056780.png" alt="image-20211011112056780"></p><p>武大的个人得分分为背景评估（40%）、笔试（20%）、面试（40%）。背景评估根据本科院校和获奖、论文情况吧，虽然笔试占比不重，但是个人感觉还是要重视的，因为我就是死在笔试了。</p><p>网安夏令营是先进行笔试，笔试总分100分，计网与安全（计网+少部分密码学）50分，程序设计50分。那天笔试的时候写第一部分还信心满满，因为计网复习的还行，卷子上的大部分题都会，结果写第二部分的时候就时间不够了，越到后面越紧张，代码都看不进去。（个人觉得我的心理素质不太行吧，后面真的都看不进去代码了）根据自己的情况，应该先作答第二部分，再作答第一部分。时间到了果然没有做完（哭唧唧）。</p><p>考完就觉得无了，已经摆正心态，决定玩了。第二天早上就是面试。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">英语自我介绍(<span class="hljs-number">3</span><span class="hljs-built_in">min</span>)<br>为什么西电这么多来武大的<br>介绍项目<br>能否取得保研资格<br>是否还有别的学校夏令营<br>你未来想做哪个方向<br>软件与系统安全讲了哪些东西<br></code></pre></td></tr></table></figure><p>面试自我感觉良好，结果就由笔试情况定了。</p><p>武大的校园很大，当时放假了吧，感觉人很少，没有人气的样子，校区比较偏，时常可以看到天空的飞机，食堂的饭比较贵，种类也比较少，不太喜欢，不过硬件设施确实很好，我们还去参观了他们的宿舍。（个人当时觉得还是西安好，西电yyds）。（个人评价，不喜勿喷）</p><p>结束面试以后，和小伙伴们在武汉玩了玩，逛了逛，长江、大桥、江汉路、渡船，一帮nice的人，也是不虚此行。之后由于郑州暴雨，买的高铁票停运，后来想尽办法历尽千辛转站回家，不过回家耽误了几天。（哈哈哈哈哈哈）</p><p>回家的路上，官网就发了优营名单，不出意外没有拿到优营，心里感觉还行，没有太多不舒服。</p><h3 id="国防科大网安"><a href="#国防科大网安" class="headerlink" title="国防科大网安"></a>国防科大网安</h3><p>国防科大两个学院都有网安，一个是计算机学院，一个是电子对抗学院，不过我只入营了第二个。计算机学院网安我们院一个都没有入。</p><p>国防科大网安夏令营应该是在8月23-27，电子对抗学院网安面试是在25-26日（我是第一天上午）。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">英语自我介绍 <span class="hljs-number">2</span><span class="hljs-built_in">min</span><br>政治问题：为什么要来国防科大  你觉得进去国防科大后 最大的困难  能否接受严格要求<br>自己抽题：(惨我抽到的是数据结构和人工智能。。。我复习好一点的是密码学)<br>        人工智能是什么  认识  在安全方面的应用<br>        什么是哈夫曼树 如何构造  如果叶子结点的权值是按照从小到大排的，如何在线性时间内构造哈夫曼树<br>专家提问：项目中用的哪种语言<br>        信安赛的题目以及自己做的部分<br></code></pre></td></tr></table></figure><p>最终拿到了网安的优营，不过国防科大每年收的人都很少，而且不是特别想去国防科大，所以也没有太关注这个。</p><p>夏令营的体验感还可以，开营前老师统计了尺码，邮寄了营员的T恤，后面我突然收到一个邮政快递，还不知道是谁给我邮递的，打开才知道是邮件的优秀营员证书，证书看着很豪华。</p><h3 id="东南网安"><a href="#东南网安" class="headerlink" title="东南网安"></a>东南网安</h3><p><strong>东南网安今年的夏令营体验极差。</strong></p><p>本来7月的夏令营由于疫情推迟到8月底，学院开始了骚操作：根据个人情况在未参加面试之前就决定了每个人是学硕、专硕还是无锡专硕，而且不能变化。我被安排了专硕，很多同学都因为这个政策对东南失去了好感。</p><p>夏令营先进行导师组介绍，之后在群里面做了一个在线文档，有一个Excel是老师的招生名额（学硕、专硕、无锡专硕）还有第一志愿第二志愿报考该老师的学生数量，另外一个Excel就是每个学生填报的第一志愿第二志愿老师。</p><p>好嘛，又开始旱的旱死，涝的涝死，很多老师都是第一志愿第二志愿十几二十个人填报，而且很多老师都是只考虑第一志愿的学生（因为人太多了，老师有的挑），我就选了一个老师，也只面了第一志愿的老师，因为第二志愿老师只面试第一志愿报他的学生，5min随便面了一下，因为已经对东南没有好感了，果不其然，成功进入wl。</p><p>预料之中的，东南被鸽惨了，9.27日晚上给我发了消息，我拒了。</p><h2 id="预推免经历"><a href="#预推免经历" class="headerlink" title="预推免经历"></a>预推免经历</h2><h3 id="哈工深计算机"><a href="#哈工深计算机" class="headerlink" title="哈工深计算机"></a>哈工深计算机</h3><p>夏令营的时候，哈工深的bar是很高的，堪比清北。投预推免的时候也没想着能入。</p><p>哈工深预推免有好几个批次，我好像是第二批次。考核分为两部分，机考和面试。</p><blockquote><p>机考</p></blockquote><p>机考不是考编程题，是选择题和判断题（我那一批次是这样的），时间100min，涉及408四门课程，离散数学，信息安全数学基础，数据库原理（内容还是很多很杂的），我提前看了往年的一些题，发现机考的时候也有原题，70选择+10判断，总分150，楼主只考了95（发现做不完。。判断题全是蒙的），如果想要机考原题，可以私聊我。机考过了70就可以面试，当天下午就会告诉你有没有面试资格。</p><blockquote><p>面试</p></blockquote><p>面试时间15-20分钟。自我介绍（5min）+计算思维题（5min）之前是这样通知的，但是一进去我就蒙了，面试老师让3min介绍，但我还是按5min进行的，之后抽计算思维题，我抽了8（印象深刻），结果是算法题，5min看完题并且说如何做，我当时的题是小明分糖果（根本不会。。。），就看完题一通说（也不知道说的啥就到时间了），老师还在问我咋实现之类的，还没回答老师的问题，计算思维题的时间就结束了，之后老师问为什么数据结构考的这么低（我的痛），我说可能是编程能力不强吧（脑子瓦特了，怎么能这么说），之后问项目，代码多少行，说了之后感觉就没了。结束面试得下午四点左右就收到了不通过的通知（~~~~~~~···）</p><p>哈工深的效率还是很高的，当天出结果。</p><h3 id="中科大网安"><a href="#中科大网安" class="headerlink" title="中科大网安"></a>中科大网安</h3><p>中科大是我最开始最想去的学校（我觉得中科大应该是我实力能去的最好的学校了），按照往年的情况，我的排名夏令营入营是没有问题的，但是由于今年特别的卷，rank卡的很严（最好可以提前联系老师，让老师捞进去）。</p><p>由于中科大网安的老师也并不多，我也一直只看了一个老师，这个老师也是我最想去的，我也从7月就联系了科大这一个老师，结果没有入夏令营。</p><p>由于科大网安夏令营已经发了很多优营了，而且很多优营的同学也没有找到老师，我最开始以为今年没有预推免了。意外的是，在9.15官网发布了预推免的通知，在之前的夏令营系统进行预报名。报完名的某一天就收到了预推免面试通知。</p><p>面试时间为9.22 （每人20分钟，PPT自我介绍5分钟+英语5分钟+专业10分钟）只需要单机位</p><p>学院面试的提问环节，老师问了我一些专业问题（我之前联系的老师），其他的老师问的有学生工作之类的，总之就是没问什么东西。学院面试来说容易一些。一共好像2组，每组10人，通过的大概有15人左右。</p><p>我联系了之前7月就联系的老师，老师说晚上和我电话聊一聊。晚上大概九点的时候，和老师电话面试近1h，老师问了很多东西，而且老师非常看重实践，每问到一个知识的时候，老师可能就会询问你这个东西在实际当中该如何实现他，总之，理论的东西我回答的还行，但是实践的那一部分就是我的短板。面试第二天，我下午给老师发短信询问结果，过了大概一两个小时，老师说欢迎我到老师的实验室，我激动地问老师可以给老师打个电话吗，老师就把电话打过来了，说接收我，我就和老师说了双选邮件的事情，并且加了老师微信。</p><p>之后我就和老师完成了双选，并且经过询问，我拿到的是学硕offer。本来都觉得这是最好的结果了，可惜后面又收到了浙大网安学硕offer，纠结了一番之后，还是选择了这位老师，这个方向。</p><h3 id="浙大网安"><a href="#浙大网安" class="headerlink" title="浙大网安"></a>浙大网安</h3><p>报了浙大网安学院，然后一直没收到通知，以为凉了，某天中午一个同学给我说，我才看到钉钉拉了一个群，我们是外校网安组2，组里面人有20个左右，9.24下午开始面试。</p><p>联系了一个老师，老师某一天给我打了电话，了解情况以后说自己已经没有直博&#x2F;直硕的名额，问我愿不愿意让我把简历推给同组的其他老师，我同意了。当天下午，其中一个老师给我打了电话，介绍了自己的方向，然后问我个人的意愿，说如果想报他或者不报他给老师说一声，我觉得这个老师比较push，就没有给老师准确的答复（因为感觉老师的意思是大四就要过去跟着做了）</p><p>过了几天，又有一个老师给我打电话，介绍了自己的方向，老师是做语音方面的，人很年轻，刚刚博士毕业，带了两届学生好像，当时和老师达成的是如果我去浙大的话，就报这个老师。</p><p>浙大面试20min，先是5min自我介绍（其中自己1min做英文），之后就是老师根据你的情况会问你一些问题。（个人觉得专业课问的不多）。</p><p>浙大结果应该是26号出的（好像），而我前几天刚刚和中科大的老师达成双选。浙大的老师刚刚博士毕业，做语音方向，科大的老师是一个比较厉害的老师，做密码工程&#x2F;应用。浙大的牌子、地理位置和环境也比科大好；经过一段时间的犹豫之后，还是选择了科大，不想鸽老师，而且我也不是特别想做语音的方向（虽然很多人都鸽了科大去了浙大，也不知道自己的选择究竟对不对）。</p><h3 id="软件所"><a href="#软件所" class="headerlink" title="软件所"></a>软件所</h3><p>由于我本科专业是信息安全，而且研究生想走网安方向，因此我报了软件所的可信实验室（做安全的）</p><p>软件所预推免没有明确时间，但是能够早报就早报（我是等六学期排名出了才报名的），某一天我就收到了入选预推免面试得通知</p><p>预推免面试分为面试和笔试，早上面试，下午笔试</p><p>面试TCA 的一共有8个同学，4个京内，4个京外，京外线上。</p><p><code>上午是面试</code></p><p>面试（好像是20min）先进行英文PPT自我介绍，紧接着是英文问题。之后是老师们问专业问题，一个老师看到我简历上有软件与系统安全的课程，就问了这门课学了什么，然后问了栈溢出堆溢出的相关问题（这里老师问的时间很长），另外一个老师看到我之前做过RSA 的破译，就问我这个在实际过程中能够实现吗，之后是一个女老师问我之前做过博物馆讲解员，是如何处理学习与它之间的关系的。</p><p><code>下午是笔试</code></p><p>笔试 计算机相关或者数学二选一，由于我看到数学就不想做，所以一上来就选择了计算机的那套题，计算机这套题有6道题，平常不做的话还挺难的</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>.（<span class="hljs-number">1</span>）建立小根堆（<span class="hljs-number">2</span>）建立平衡二叉树？这里记不太清了<br><span class="hljs-number">2</span>.从<span class="hljs-number">2700</span>个元素中，选出最小的<span class="hljs-number">8</span>个元素，使用哪种排序算法最好<br><span class="hljs-number">3</span>.有关于死锁的 <span class="hljs-built_in">p1</span>、<span class="hljs-built_in">p2</span>、<span class="hljs-built_in">p3</span>争夺<span class="hljs-built_in">s1</span>、<span class="hljs-built_in">s2</span>、<span class="hljs-built_in">s3</span>三种资源<br> （<span class="hljs-number">1</span>）会出现什么情况，为什么？<br> （<span class="hljs-number">2</span>）如何合理地分配资源，为什么？<br><span class="hljs-number">4</span>.瀑布模型？快速原型模型？面向对象的概念与特征、软件测试的步骤（这道题都不会写，菜死了）<br><span class="hljs-number">5</span>.是一个改错题（不过感觉哪都对，┭┮﹏┭┮）<br><span class="hljs-number">6</span>.考察union里面的变量共用一个内存空间<br></code></pre></td></tr></table></figure><p>听朋友说数学的比较简单，直接晕掉</p><p>软件所的结果真的出的慢，夏令营的时候听说一个月才出，预推免结果也是27号晚上才出，这个时候我也已经有其他offer了，所以就拒掉了。</p><h3 id="武大网安、北航网安"><a href="#武大网安、北航网安" class="headerlink" title="武大网安、北航网安"></a>武大网安、北航网安</h3><p>之前因为没有什么offer，就报了一下武大和北航网安的预推免，都入了，但是后面已经拿到中科大网安学硕offer和浙大网安学硕offer，就没有参加这两个学校的预推免面试。</p><h3 id="计算所"><a href="#计算所" class="headerlink" title="计算所"></a>计算所</h3><p>本来没想着报，因为计算所需要推荐信，我之前没有准备过，还需要开有推免资格的证明（这个那个时候还没出），我在截止那天上午最后半个小时报了一下，那些材料都没交。结果收到了入预推免的通知，不过计算所是线下而且那一天和学院的推免面试撞了，就没去。</p><h2 id="最终去向"><a href="#最终去向" class="headerlink" title="最终去向"></a>最终去向</h2><p>在浙大网安和中科大网安两个选择中纠结了很久，两个各自有各自的优点好处，很多人给我的建议是浙大，不过我最终还是选择了中科大网安，选择了我最开始想去的老师和学校。落子无悔，希望能够有所成长和收获。</p><h2 id="一些经验和提醒"><a href="#一些经验和提醒" class="headerlink" title="一些经验和提醒"></a>一些经验和提醒</h2><h3 id="准备方向（rank、竞赛、科研）"><a href="#准备方向（rank、竞赛、科研）" class="headerlink" title="准备方向（rank、竞赛、科研）"></a>准备方向（rank、竞赛、科研）</h3><p>个人认为，在保研的过程中，<strong>rank是最为重要的</strong>，所以准备保研的学弟学妹们首先要保证自己的rank很好（rank1、2真的很香），而且很多学校就是看rank，小专业的rank1、2可能比大专业的前5%还要好。rank是夏令营&#x2F;预推免的入场券，有了入场券后面都会有很大的机会。</p><p><strong>竞赛和科研锦上添花</strong></p><p>在夏令营面试之前，最好自己至少有一个项目（这个项目可以是国创、竞赛里面的项目或者科研项目），当然这样简历也好看一些。在面试前，要保证自己对于这个项目足够的了解，并且清楚自己所做的部分。有了项目后，在后面的面试中会占据很大的优势。因为很多学校的面试时间不长，而如果<strong>有项目经历的话，老师很有可能就基本只问项目，专业课就问的少了</strong>；如果没有项目经历的话，专业课应该会问的比较多。</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>要了解往届学长学姐的去向，这样的话可以大致知道自己应该去投哪些学校。然后需要根据自己的情况，寻找和自己情况（rank、竞赛）相似的学长学姐，大致知道自己的水平可以保到哪一等级的学校。如果还是线上举办夏令营&#x2F;预推免的话，建议海投策略（冲一冲、稳一稳、保一保），多投一定不会让自己有遗憾（因为大家都会海投，你不这样吃亏的是自己）。</p><h3 id="材料准备-1"><a href="#材料准备-1" class="headerlink" title="材料准备"></a>材料准备</h3><p>在夏令营开始前，最好把一些常见得需要的材料准备齐全。以下是需要具备的材料：</p><p><strong>·个人简历</strong></p><p>个人觉得个人简历很重要，很多老师都会根据你的简历来给你提问。一般来说，个人简历包括教育背景、获奖情况、项目经历、个人技能、学生工作、个人评价……(根据自己的情况选择)，个人简历不要太过花哨，可以超级简历找一个看着顺眼的，进行修改。</p><p>可以在简历上面写自己一些考的高的专业课成绩，但是在面试的时候一定要保证上面写到的课程都已经复习过了，不然问到的话会很尴尬。（我就是刚开始写了好多门，后来面一次试删几门，后来就剩下几门自己复习过的）</p><p><strong>·前五学期专业排名证明（带学院教务处盖章）</strong><br><strong>·前五学期成绩单</strong><br><strong>·四六级证书</strong><br><strong>·获奖证书</strong><br><strong>·身份证</strong><br><strong>·学生证</strong><br><strong>·一寸免冠照片电子版（红底或者蓝底应该都行）</strong></p><p>以上的文件都需要电子版（如果是线上夏令营&#x2F;预推免的话），可以使用万能扫描王扫描或者到打印店扫描成PDF&#x2F;JPG</p><p><strong>·个人陈述（以1000字为主，还有800、1500、2000字的适当删减或者扩充）</strong><br><strong>·个人介绍PPT</strong><br><strong>·自我介绍（3min、5min，离谱的还有1min）||中英文两版，可能会配合上面的PPT一起</strong></p><p>以上的材料都和个人简历相对应，进行详细介绍</p><p><strong>·常见的英文问题</strong></p><p>大多数学校考察英语时都会问一下常见的英语问题，例如介绍你的个人情况、家乡、大学、所在城市、家庭，你的优缺点、爱好等等，这些你都可以提前准备，来应对提问。</p><p><strong>·专家推荐信（优秀的同学一定要准备）</strong></p><p>很多top的大学都需要专家推荐信，甚至是专门针对自己学校的专家推荐信，这个时候就需要我们准备两份通用的，在需要专门的推荐信时再去找老师，一般是两位副教授及以上（有的可能辅导员也行）。我就因为没有准备这个材料，一些学校就没有进行申请,也算是一个遗憾吧。</p><h3 id="课程复习"><a href="#课程复习" class="headerlink" title="课程复习"></a>课程复习</h3><p>网安或者相关专业在准备夏令营&#x2F;预推免的时候，推荐复习以下科目：</p><p>专业相关：<strong>现代密码学、网络安全基础、计算机网络、操作系统、数据结构</strong>、计组（很多学校都不问）、软件与系统安全、数据库（或者一些AI 相关的课程）</p><p>数学相关：<strong>信息安全数学基础、线性代数</strong>、概率论、离散数学、高数</p><p>如果有时间就都复习一遍比较好，没时间的话把上面加粗的要过一边（夏令营&#x2F;预推免期间可能会过很多次）</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>要提前思考自己的选择，是<strong>选择直博还是直硕</strong>，直硕是学硕还是专硕，<strong>研究所还是高校</strong>。首先要早早思考直博或者直硕，因为如果早早决定直博的话，获得offer学校的等级可能更高，因为后面机会可能会少一些。其次是决定研究所还是高校，研究所的话可能没有title，并且氛围不会像高校一样，但会是另一种生活，所以需要提前自己决定一下。<strong>越早决定越好</strong></p><h3 id="联系老师"><a href="#联系老师" class="headerlink" title="联系老师"></a>联系老师</h3><p>1.要知道投的学校是强com还是弱com，因为有的学校是通过学院面试拿到优营就一定有offer，有的则是需要学院优营+老师接收才算拿到offer（例如中科大，面试通过需要找到老师接收才行，今年很多优营都没有找到老师接收，所以要提前联系老师）。</p><p>2.自己想去的学校最好都联系一下老师（如果有一些学校只是用来保底，基本不会去，就没必要联系，因为浪费精力，最后鸽老师也不好），个人觉得一个学校联系好一个老师（至多两个）就行（但有的同学是一个学校联系好几个，我觉得这样不太好，不过仅供参考，还是自己决定联系几位老师）。尤其是不要联系同一个课题组的几位老师。</p><p>3.如果决定不去之前联系好的老师那里，要趁早和老师说清楚情况，尽快释放自己不要的offer，这样的话也不会影响老师的招生。</p><h3 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h3><h3 id="最重要的"><a href="#最重要的" class="headerlink" title="最重要的"></a>最重要的</h3><p><strong>自信且坚持。</strong>保研的战线会拖得很长，可能是从3、4月，6、7月开始，一直到9.28才结束战斗，在这一段时间，可能会不断重复着报名、复习、面试。过程中会有失意，会有失败，可能你也会怀疑自己，怀疑自己的水平，怀疑自己的定位。</p><p><strong>但是请你坚持下来，静下心来，保持自信，坚持到9.28，一定能够拿到自己满意的offer！</strong></p>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>保研 2021</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2021/10/08/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/10/08/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>这里主要是hexo文档中常见的一些命令，在使用hexo+github来搭建和使用博客时，也会使用其中的命令，这里做一个总结。</p><span id="more"></span><p>最近忙完了近一年来最重要的事情，开始有了比较多的时间来自我支配，博客几年前就搭建好了，但是一直没有管理，终于能够做一下自己一直想做的事情了。</p><h2 id="hexo-官方文档"><a href="#hexo-官方文档" class="headerlink" title="hexo 官方文档"></a><a href="https://hexo.io/zh-cn/docs/commands.html">hexo 官方文档</a></h2><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo init [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--path</code></td><td>自定义新文章的路径</td></tr><tr><td><code>-r</code>, <code>--replace</code></td><td>如果存在同名文章，将其替换</td></tr><tr><td><code>-s</code>, <code>--slug</code></td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-keyword">new</span> page <span class="hljs-comment">--path about/me</span><br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deploy</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr><tr><td><code>-b</code>, <code>--bail</code></td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td>强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td><code>-c</code>, <code>--concurrency</code></td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--port</code></td><td>重设端口</td></tr><tr><td><code>-s</code>, <code>--static</code></td><td>只使用静态文件</td></tr><tr><td><code>-l</code>, <code>--log</code></td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>, <code>--generate</code></td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-o</code>, <code>--output</code></td><td>设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><hr><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hexo">hexo new &quot;postName&quot; #新建文章<br>hexo new page &quot;pageName&quot; #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）<br>hexo deploy #部署到GitHub  <br>hexo help  # 查看帮助<br>hexo version  #查看Hexo的版本<br></code></pre></td></tr></table></figure><p>缩写</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">hexo n <span class="hljs-operator">=</span><span class="hljs-operator">=</span> hexo new<br>hexo g <span class="hljs-operator">=</span><span class="hljs-operator">=</span> hexo generate<br>hexo s <span class="hljs-operator">=</span><span class="hljs-operator">=</span> hexo server<br>hexo d <span class="hljs-operator">=</span><span class="hljs-operator">=</span> hexo deploy<br></code></pre></td></tr></table></figure><p>组合命令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> s -g <span class="hljs-comment">#生成并本地预览</span><br>hexo d -g <span class="hljs-comment">#生成并上传</span><br></code></pre></td></tr></table></figure><h3 id="本地生成md文件"><a href="#本地生成md文件" class="headerlink" title="本地生成md文件"></a>本地生成md文件</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;postName&quot;</span> <span class="hljs-meta">#新建文章</span><br></code></pre></td></tr></table></figure><p>默认生成内容为</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: hexo常用命令<br>date: 2021<span class="hljs-string">-10</span><span class="hljs-string">-08</span> 09:43:05<br><span class="hljs-keyword">tags:</span><br></code></pre></td></tr></table></figure><p>一般完整格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: postName #文章页面上的显示名称，一般是中文<br>date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改<br>categories: 默认分类 #分类<br>tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格<br>description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面<br><span class="hljs-section">hide: [true/flase] 隐藏文章</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="如何让博文列表不显示全部内容"><a href="#如何让博文列表不显示全部内容" class="headerlink" title="如何让博文列表不显示全部内容"></a>如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，在合适的位置加上<code>&lt;!--more--&gt;</code>即可让博客不显示全部内容，显示效果如下：</p><p><img src="https://z3.ax1x.com/2021/10/09/5FzwND.png"></p><p>参考</p><p>[1] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98</a></p><p>[2] <a href="https://hexo.io/zh-cn/docs/commands.html">https://hexo.io/zh-cn/docs/commands.html</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>miracl椭圆曲线函数</title>
    <link href="/2020/12/26/miracl%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%87%BD%E6%95%B0/"/>
    <url>/2020/12/26/miracl%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>对miracl库中关于椭圆曲线的函数进行总结。</p><span id="more"></span><h2 id="miracl椭圆曲线函数"><a href="#miracl椭圆曲线函数" class="headerlink" title="miracl椭圆曲线函数"></a>miracl椭圆曲线函数</h2><h4 id="ebrick-init"><a href="#ebrick-init" class="headerlink" title="ebrick_init"></a>ebrick_init</h4><p>函数原型：BOOL ebric_init(binst,x,y,a,b,n,w,nb)</p><p>参数类型：ebrick *binst;   big x,y; big a,b,n;  int w,nb;</p><p>参数意义：指向当前实例binst的指针，线上的不动点G&#x3D;（x，y），y2&#x3D;x3+ax+b，模n，以及指数nb中要使用的最大位数</p><p>函数作用：曲初始化一个计算前GF(p)椭圆曲线乘法的梳状方法的实例，内部内存被分配给2^w个椭圆曲线点，这些点将被用于计算和存储</p><p>返回值：如果一切顺利，则返回TRUE；如果出现问题，返回FALSE。</p><h4 id="ebrick2-init"><a href="#ebrick2-init" class="headerlink" title="ebrick2_init"></a>ebrick2_init</h4><p>函数原型：BOOL ebrick2_init(binst,x,y,A,B,m,a,b,c,nb)</p><p>参数类型：ebrick2 *binst;  big x,y;   big A,B;    int m,a,b,c,nb; </p><p>参数意义：指向当前实例binst的指针、曲线y2 + xy &#x3D; x3 + Ax2 +  B上的固定点G&#x3D;(x，y)、字段参数m、a、B、c以及指数nb中要使用的最大位数。对于三项式基础，设置b &#x3D; 0。</p><p>函数作用：初始化带预计算的GF（2m）椭圆曲线乘法的梳状法实例</p><p>返回值：如果一切顺利，则返回TRUE；如果出现问题，返回FALSE</p><h4 id="ecurve-add"><a href="#ecurve-add" class="headerlink" title="ecurve_add"></a>ecurve_add</h4><p>函数原型： void ecurve_add(p,pa) </p><p>参数类型： epoint  *p,*pa; </p><p>函数作用：(素域上)点的加法运算，pa&#x3D;pa+p</p><h4 id="ecurve2-add"><a href="#ecurve2-add" class="headerlink" title="ecurve2_add"></a>ecurve2_add</h4><p>函数原型：void ecurve2_add(p,pa) </p><p>参数类型：epoint *p,*pa;</p><p>函数作用：在GF(2^m)椭圆曲线上. pa&#x3D;pa+p</p><h4 id="ecurve-init"><a href="#ecurve-init" class="headerlink" title="ecurve_init"></a>ecurve_init</h4><p>函数原型：void ecurve_init(A,B,p,type) </p><p>参数类型：big A,B,p;   int type; </p><p>函数作用：初始化当前活动GF(p)椭圆曲线的内部参数，y2 &#x3D;x3 + Ax + B mod p，type为MR_PROJECTIVE or  MR_AFFINE,</p><h4 id="ecurve2-init"><a href="#ecurve2-init" class="headerlink" title="ecurve2_init"></a>ecurve2_init</h4><h4 id="ecurve-mult"><a href="#ecurve-mult" class="headerlink" title="ecurve_mult"></a>ecurve_mult</h4><p>函数原型：void ecurve_mult(k,p,pa)</p><p>参数类型： big k;   epoint  *p,*pa; </p><p>函数作用：将GP(p)椭圆曲线上的点乘以一个整数, pa&#x3D;k*p.  </p><h4 id="ecurve2-mult"><a href="#ecurve2-mult" class="headerlink" title="ecurve2_mult"></a>ecurve2_mult</h4><h4 id="ecurve-mult2"><a href="#ecurve-mult2" class="headerlink" title="ecurve_mult2"></a>ecurve_mult2</h4><p>函数原型：void ecurve_mult2(k1,p1,k2,p2,pa) </p><p>参数类型：big k1,k2;  epoint *p1,*p2,*pa; </p><p>函数作用：点乘加快速运算。计算GF(p)椭圆曲线上的点k1*p1+k2*p2。这比进行两次单独的乘法和加法要快。 pa &#x3D; k1*p1+k2*p2 </p><h4 id="ecurve2-mult2"><a href="#ecurve2-mult2" class="headerlink" title="ecurve2_mult2"></a>ecurve2_mult2</h4><h4 id="ecurve-multi-add"><a href="#ecurve-multi-add" class="headerlink" title="ecurve_multi_add"></a>ecurve_multi_add</h4><p>函数原型：void ecurve_multi_add(m,x,w) </p><p>参数类型：int m; epoint **x,**w; </p><p>函数作用： w[i]&#x3D;w[i]+x[i] , i &#x3D;0 - m-1 （使用仿射坐标）</p><h4 id="ecurve2-multi-add"><a href="#ecurve2-multi-add" class="headerlink" title="ecurve2_multi_add"></a>ecurve2_multi_add</h4><h4 id="ecurve-multn"><a href="#ecurve-multn" class="headerlink" title="ecurve_multn"></a>ecurve_multn</h4><p>函数原型：void ecurve_multn(n,k,p,pa) </p><p>参数类型： int n;  big *k; epoint **p</p><p>参数意义：整数n，n个大数字k[]的数组，n个点的数组。结果在pa中返回。</p><p>函数作用：在GF(p)上计算 k[0]*p[0] + k[1]*p[1] + … + k[n-1]*p[n-1] , n&gt;2</p><h4 id="ecurve2-multn"><a href="#ecurve2-multn" class="headerlink" title="ecurve2_multn"></a>ecurve2_multn</h4><h4 id="ecurve-sub"><a href="#ecurve-sub" class="headerlink" title="ecurve_sub"></a>ecurve_sub</h4><p>函数原型：void ecurve_sub(p,pa) </p><p>参数类型：epoint *p,*pa; </p><p>参数意义：GF（p）上两点</p><p>函数作用：pa &#x3D; pa-p. </p><h4 id="ecurve2-sub"><a href="#ecurve2-sub" class="headerlink" title="ecurve2_sub"></a>ecurve2_sub</h4><h4 id="epoint-comp"><a href="#epoint-comp" class="headerlink" title="epoint_comp"></a>epoint_comp</h4><p>函数原型：BOOL epoint_comp(p1,p2)</p><p>参数类型：epoint\ *p1,*p2; </p><p>函数作用：比较当前在GF(p)椭圆曲线上的两点</p><p>返回值：如果点数相同，则返回TRUE，否则返回ALSE。</p><h4 id="epoint2-comp"><a href="#epoint2-comp" class="headerlink" title="epoint2_comp"></a>epoint2_comp</h4><h4 id="epoint-copy"><a href="#epoint-copy" class="headerlink" title="epoint_copy *"></a>epoint_copy *</h4><p>函数原型：void epoint_copy(p1,p2) </p><p>参数类型：epoint *p1,*p2; </p><p>函数作用：将GF(p)椭圆曲线上的一个点复制到另一个点,p2&#x3D;p1</p><h4 id="epoint2-copy"><a href="#epoint2-copy" class="headerlink" title="epoint2_copy *"></a>epoint2_copy *</h4><h4 id="epoint-free"><a href="#epoint-free" class="headerlink" title="epoint_free *"></a>epoint_free *</h4><p>函数原型：void epoint_free(p) </p><p>参数类型：epoint *p; </p><p>函数作用：释放与GF(p)椭圆曲线上的点p相关联的内存</p><h4 id="epoint-get"><a href="#epoint-get" class="headerlink" title="epoint_get"></a>epoint_get</h4><p>???</p><p>函数原型：int epoint_get(p,x,y) </p><p>参数类型：epoint *p; big x,y; </p><p>函数作用：取出p点的x,y坐标</p><p>返回值：y的最低有效位</p><h4 id="epoint2-get"><a href="#epoint2-get" class="headerlink" title="epoint2_get"></a>epoint2_get</h4><h4 id="epoint-getxyz"><a href="#epoint-getxyz" class="headerlink" title="epoint_getxyz"></a>epoint_getxyz</h4><p>函数原型：void epoint_getxyz(p,x,y,z) </p><p>参数类型：epoint *p; big x,y,z; </p><p>函数作用：提取活动**GF(p)**椭圆曲线上一点的原始(x，y，z)坐标</p><h4 id="epoint2-getxyz"><a href="#epoint2-getxyz" class="headerlink" title="epoint2_getxyz"></a>epoint2_getxyz</h4><h4 id="epoint-init"><a href="#epoint-init" class="headerlink" title="epoint_init"></a>epoint_init</h4><p>函数原型：epoint* epoint_init() </p><p>函数作用：将内存分配给GF(p)椭圆曲线上的一个点，并将其<strong>初始化为“无穷远点”</strong>。</p><p>返回值:返回epoint类型点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">C=epoint_init();<br></code></pre></td></tr></table></figure><p><strong>确保通过调用该函数初始化的所有椭圆曲线点最终通过调用epoint_free被释放。否则将导致内存泄漏</strong></p><h4 id="epoint-init-mem"><a href="#epoint-init-mem" class="headerlink" title="epoint_init_mem"></a>epoint_init_mem</h4><h4 id="epoint2-norm"><a href="#epoint2-norm" class="headerlink" title="epoint2_norm"></a>epoint2_norm</h4><h4 id="epoint-set"><a href="#epoint-set" class="headerlink" title="epoint_set"></a>epoint_set</h4><p>函数原型： BOOL epoint_set(x,y,lsb,p)</p><p>参数类型： big x,y;   int lsb; epoint *p;</p><p>参数意义：</p><p>函数作用：设置点p的（x,y）坐标，（x,y）在曲线上则返回true</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">p=epoint_init(); <br>epoint_set(x,x,<span class="hljs-number">1</span>,p); <br>    <span class="hljs-comment">/* decompress p */</span><br></code></pre></td></tr></table></figure><h4 id="epoint2-set"><a href="#epoint2-set" class="headerlink" title="epoint2_set"></a>epoint2_set</h4><h4 id="epoint-x"><a href="#epoint-x" class="headerlink" title="epoint_x"></a>epoint_x</h4><p>函数原型： BOOL epoint_x(x) </p><p>参数类型：big x; </p><p>函数作用：测试参数x是否是曲线上一点的有效坐标。用这种方法先测试一个x坐标，要比直接通过调用epoint_set在曲线上设置快，因为这样可以避免昂贵的模平方根。</p><p>返回值:如果x是曲线点的坐标，则为真，否则为假</p><h4 id="mul-brick"><a href="#mul-brick" class="headerlink" title="mul_brick"></a>mul_brick</h4><h4 id="mul2-brick"><a href="#mul2-brick" class="headerlink" title="mul2_brick"></a>mul2_brick</h4><h4 id="point-at-infinity"><a href="#point-at-infinity" class="headerlink" title="point_at_infinity *"></a>point_at_infinity *</h4><p>函数原型：BOOL point_at_infinity(p) </p><p>参数类型：epoint *p; </p><p>函数作用：测试椭圆曲线点是否是“无穷远点”。</p><p>返回值：如果p是无穷远点，则为True，否则为false</p><h4 id="sha256-init"><a href="#sha256-init" class="headerlink" title="sha256_init"></a>sha256_init</h4><p>函数原型：sha256_init(psh)</p><p>参数类型：sha256 *psh</p><p>函数功能：初始化安全哈希算法SHA-256的实例。必须在重新使用前调用。</p><h4 id="sha256-process"><a href="#sha256-process" class="headerlink" title="sha256_process"></a>sha256_process</h4><p>函数原型：void shs256_process(psh,ch)</p><p>参数类型：sha256 *psh; int ch;</p><p>函数功能：处理单个字节。通常调用多次以向哈希进程提供输入。所有已处理字节的哈希值可通过后续调用shs256_hash来检索。</p><h4 id="sha256-hash"><a href="#sha256-hash" class="headerlink" title="sha256_hash"></a>sha256_hash</h4><p>函数原型：void shs256_hash(psh,hash)</p><p>参数类型：sha256 *psh; char hash[32];</p><p>函数功能：在提供的数组中生成一个32字节（256位）的哈希值</p><p>参考文献：</p><p>1.官方文档</p><p>2.<a href="https://www.cnblogs.com/Higgerw/p/10164179.html">https://www.cnblogs.com/Higgerw/p/10164179.html</a></p><p>3.<a href="https://blog.csdn.net/weixin_30734435/article/details/95364200">https://blog.csdn.net/weixin_30734435/article/details/95364200</a></p>]]></content>
    
    
    <categories>
      
      <category>cryptography</category>
      
      <category>handbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cryptography</tag>
      
      <tag>skills</tag>
      
      <tag>miracl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mircal常用函数手册</title>
    <link href="/2020/12/21/mircal%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%8C/"/>
    <url>/2020/12/21/mircal%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>由于最近做实验需要使用miracl库，所以对miracl库中常用的函数进行总结。</p><span id="more"></span><h2 id="mircal常用函数手册"><a href="#mircal常用函数手册" class="headerlink" title="mircal常用函数手册"></a>mircal常用函数手册</h2><h4 id="absol"><a href="#absol" class="headerlink" title="absol"></a>absol</h4><p>函数原型：void absol(x,y)</p><p>flash x,y  or  big x,y</p><p>功能：取x的绝对值，y&#x3D;|x|</p><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>函数原型：void add(x,y,z)</p><p>参数类型：big x,y,z</p><p>功能：z&#x3D;x+y</p><h4 id="brand"><a href="#brand" class="headerlink" title="brand"></a>brand</h4><p>函数原型：int brand()</p><p>功能：返回值一个随机整数</p><p>限制：首次使用前必须先调用irand。</p><p>注意：此生成器的加密能力不强。对于加密应用程序，请使用强例程。</p><h4 id="bigbits"><a href="#bigbits" class="headerlink" title="bigbits"></a>bigbits</h4><p>函数原型：void bigbits(n,x)</p><p>参数类型：int n, big x</p><p>功能：产生一个n位的大整数，初始化随机种子由irand函数实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">irand(time(<span class="hljs-literal">NULL</span>));（头文件<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span>）</span><br></code></pre></td></tr></table></figure><h4 id="big-to-bytes"><a href="#big-to-bytes" class="headerlink" title="big_to_bytes"></a>big_to_bytes</h4><p>函数原型：int <strong>big_to_bytes</strong>(max,x,ptr,justify)</p><p>参数类型：int max;big x;char *ptr;BOOL justify</p><p>功能：描述：将正数x转换为二进制八位字符串</p><p>参数：大数字x和字节数组ptr，长度最大。进行错误检查，以确保函数在最大值&gt;0时不会超出ptr的限制。如果max&#x3D;0，则不执行检查。如果max&gt;0且justify&#x3D;TRUE，则输出将正确对齐，否则将抑制前导零。</p><p>返回值：在ptr中生成的字节数。如果justify&#x3D;TRUE，则返回值为max。</p><p>限制：如果“正当性”为TRUE，则最大值必须大于0</p><h4 id="bytes-to-big"><a href="#bytes-to-big" class="headerlink" title="bytes_to_big"></a>bytes_to_big</h4><p>函数原型：void bytes_to_big(len,ptr,x)</p><p>参数类型：int len;  char *ptr;  big x;</p><p>功能：将二进制八位字节字符串转换为大数字。二进制到大的转换。</p><p>参数：指向长度为len的字节数组ptr的指针，以及一个大的结果x。</p><h4 id="—cinnum"><a href="#—cinnum" class="headerlink" title="—cinnum"></a>—cinnum</h4><p>函数原型：int cinnum(x,f)</p><p>参数类型：flash x; FILE *f</p><p>描述:从键盘或文件中输入一个flash数字，以实例变量IOBASE的当前值作为基数。可以使用斜杠“&#x2F;”来表示分子和分母，也可以使用基数点输入闪存数。</p><p>参数：一个big&#x2F;flash数字x和一个文件描述符f。从键盘输入时，将f指定为stdin，否则指定为其他打开文件的描述符。要强制输入固定数量的字节，请在调用cinnum之前将实例变量INPLEN设置为所需的数量。</p><p>返回值：输入字符数。</p><h4 id="cinstr"><a href="#cinstr" class="headerlink" title="cinstr"></a>cinstr</h4><p>函数原型：int cinstr(x,s)</p><p>参数类型：flash x; char *s</p><p>功能说明: 将大数字符串转换成大数</p><p>参数：一个大的&#x2F;flash数字x和一个字符串s。</p><p>返回值：输入字符数</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">mip-&gt;IOBASE=<span class="hljs-number">16</span>; <span class="hljs-comment">// input large hex number into big x</span><br>cinstr(x,”AF12398065BFE4C96DB723A”);<br></code></pre></td></tr></table></figure><h4 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h4><p>函数原型：int compare(x,y)</p><p>参数类型：big x; big y</p><p>函数功能：比较两个大数的大小</p><p>返回值：x&gt;y时返回+1, x&#x3D;y时返回0, x&lt;y时返回-1  在这里需要注意的是，compare()函数比较的是两个big类型的数，此函数的返回值是int型的+1和-1   </p><p>注意:if(1)和if(-1)的结果相同</p><h4 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h4><p>函数原型：void convert (n,x)</p><p>参数类型：int n; big x</p><p>函数功能：将一个整数n转换成一个大数x</p><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>函数原型：void <strong>copy</strong>(big x, big y);</p><p>参数类型：flash x,y     big x ,y</p><p>函数功能：y&#x3D;x</p><h4 id="cotnum"><a href="#cotnum" class="headerlink" title="cotnum"></a>cotnum</h4><p>函数原型：int cotnum(x,f)</p><p>参数类型：flash x;FILE *f</p><p>描述：将当前分配给实例变量IOBASE的值作为基数，输出一个大的或闪烁的数字到屏幕或文件中。如果实例变量RPOINT&#x3D;ON，则flash数字将转换为基数点表示。否则它将作为分数输出。</p><p>参数一个大的&#x2F;闪存号x和一个文件描述符f。如果f是stdout，则输出到屏幕，否则输出到用描述符f打开的文件。</p><p>返回值：输出字符数。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mip-&gt;IOBASE=<span class="hljs-number">16</span>;<br>cotnum(x,fp);<br><span class="hljs-comment">//This outputs x in hex, to the file associated with fp. </span><br></code></pre></td></tr></table></figure><h4 id="cotstr"><a href="#cotstr" class="headerlink" title="cotstr"></a>cotstr</h4><p>函数原型：int cotstr(x,s)</p><p>参数类型：flash x; char *s</p><p>函数功能：将一个大数根据其进制转换成一个字符串</p><p>返回值: 字符串长度</p><h4 id="decr"><a href="#decr" class="headerlink" title="decr"></a>decr</h4><p>函数原型：void decr(x,n,z)</p><p>参数类型：big x,z; int n</p><p>功能说明: 将一个大数减去一个整数， z&#x3D;x-n.</p><h4 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h4><p>函数原型：void divide(x,y,z)</p><p>参数类型：big x,y,z</p><p>功能：两个大数相除，z&#x3D;x&#x2F;y; x&#x3D;x mod y，当变量y和z相同时，x为余数，商不返回（即y的值不变）；当x和z相同时，x为商，余数不返回。</p><p>注意：Example:  divide(x,y,y);&#x2F;&#x2F;x为余数，y值不</p><h4 id="ecp-memalloc"><a href="#ecp-memalloc" class="headerlink" title="ecp_memalloc"></a>ecp_memalloc</h4><h4 id="ecp-memkill"><a href="#ecp-memkill" class="headerlink" title="ecp_memkill"></a>ecp_memkill</h4><h4 id="exsign"><a href="#exsign" class="headerlink" title="exsign"></a>exsign</h4><h4 id="getdig"><a href="#getdig" class="headerlink" title="getdig"></a>getdig</h4><p>函数原型：int getdig(x,i)</p><p>参数类型：big x; int i</p><p>描述：从一个大数字中提取一个数字。</p><p>参数：一个大的数字x，和所需的数字i。</p><p>返回值：请求的数字的值。</p><p>限制：如果所需数字不存在，则返回垃圾。</p><h4 id="igcd"><a href="#igcd" class="headerlink" title="igcd"></a>igcd</h4><p>函数原型：int igcd(x,y)</p><p>参数类型：int x,y</p><p>功能：使用欧几里德方法计算两个整数的最大公约数</p><p>返回值：x和y的GCD</p><h4 id="incr"><a href="#incr" class="headerlink" title="incr"></a>incr</h4><p>函数原型：void incr(x,n,z)</p><p>参数类型：big x,z  ;    int n</p><p>功能：z&#x3D;x+n</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">incr（x，<span class="hljs-number">2</span>，x）；<span class="hljs-comment">/*这将使x增加2。*/</span><br></code></pre></td></tr></table></figure><h4 id="innum"><a href="#innum" class="headerlink" title="innum"></a>innum</h4><p>函数原型：int innum(x,f)</p><p>参数类型：flash x; FILE *f</p><h4 id="insign"><a href="#insign" class="headerlink" title="insign"></a>insign</h4><p>函数原型：void insign(s,x)</p><p>参数类型：int s; flash x</p><p>功能:</p><h4 id="instr"><a href="#instr" class="headerlink" title="instr"></a>instr</h4><p>函数原型：int instr(x,s)</p><p>参数类型：flash x; char *s</p><p>功能：</p><h4 id="irand"><a href="#irand" class="headerlink" title="irand"></a>irand</h4><p>函数原型：void irand(seed)</p><p>参数类型：long seed</p><p>功能：初始化内部随机数系统</p><h4 id="lgconv"><a href="#lgconv" class="headerlink" title="lgconv"></a>lgconv</h4><p>函数原型：void lgconv(ln,x)</p><p>参数类型：long ln; big x</p><p>功能：将长整数转换为大数格式</p><h4 id="mad"><a href="#mad" class="headerlink" title="mad"></a>mad</h4><p>函数原型：void mad(x,y,z,w,q,r)</p><p>参数类型：big x,y,z,w,q,r</p><p>功能：<em>q&#x3D;(x.y+z)&#x2F;w</em>，r为余数，如果w和q不是不同的变量，则只返回余数；如果q和r不是不同的，则只返回商。如果x和z（或y和z）相同，则不会进行z的加法。</p><h4 id="memalloc"><a href="#memalloc" class="headerlink" title="memalloc"></a>memalloc</h4><p>函数原型：void  *memalloc(n)</p><p>参数类型：int n</p><p>功能：：在一个堆访问中为n个大变量保留空间。随后，可以通过调用mirvar_mem从该内存初始化单个大&#x2F;闪存变量</p><p>返回值：指向已分配内存的指针</p><h4 id="memkill"><a href="#memkill" class="headerlink" title="memkill"></a>memkill</h4><p>函数原型：void memkill(mem,n)</p><p>参数类型：char *mem; int n</p><p>功能：删除memalloc先前分配的内存并将其设置为</p><h4 id="mirexit"><a href="#mirexit" class="headerlink" title="mirexit"></a>mirexit</h4><p>函数原型：void mirexit()</p><p>功能：在MIRACL的当前实例之后清理，并释放所有内部变量。随后调用mirsys将重新初始化MIRACL系统（清除MIRACL系统，释放所有内部变量）</p><h4 id="mirkill"><a href="#mirkill" class="headerlink" title="mirkill"></a>mirkill</h4><p>函数原型：void mirkill(x)</p><p>参数类型：big x</p><p>功能： 释放内存大数所占的内存    清除MIRACL系统，释放所有内部变量。</p><h4 id="mirsys"><a href="#mirsys" class="headerlink" title="mirsys"></a>mirsys</h4><p>函数原型：miracl *mirsys（nd,nb）</p><p>参数类型：int nd,nb</p><p>功能：初始化MIRACL系统，该函数必须在调用MIRACL库函数之前先执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"> miracl *mip=mirsys(<span class="hljs-number">500</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//初始化500位的10进行制数</span><br><span class="hljs-comment">//意思是我定义的这些变量最大长度都是500位（这个位是后面进制的位数），输入、输出、运算用的进制都是10进制。</span><br></code></pre></td></tr></table></figure><h4 id="mirvar"><a href="#mirvar" class="headerlink" title="mirvar"></a>mirvar</h4><p>函数原型：flash mirvar(iv)</p><p>参数类型：int iv</p><p>功能：通过为big&#x2F;flash变量保留适当数量的内存位置来初始化该变量。这个内存可以通过随后调用mirkill函数来释放</p><p>eg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">flash x;<br>x=mirvar(<span class="hljs-number">8</span>);<br><span class="hljs-comment">//Creates a flash variable x=8.</span><br><br></code></pre></td></tr></table></figure><h4 id="mirvar-mem"><a href="#mirvar-mem" class="headerlink" title="mirvar_mem"></a>mirvar_mem</h4><p>函数原型：flash mirvar_mem(mem,index)</p><p>参数类型：char *mem； int index</p><p>功能：从预先分配的字节数组mem初始化big&#x2F;flash变量的内存</p><p>返回值：初始化的big&#x2F;flash变量</p><p>限制：mem必须已经分配并指向足够的内存</p><h4 id="multiply"><a href="#multiply" class="headerlink" title="multiply"></a>multiply</h4><p>函数原型：void multiply(x,y,z)</p><p>参数类型：big x,y,z</p><p>功能：z&#x3D;x*y</p><h4 id="negify"><a href="#negify" class="headerlink" title="negify"></a>negify</h4><p>函数原型：void negify(x,y)</p><p>参数类型：flash x,y</p><p>功能：大数取反，y&#x3D;-x</p><h4 id="normalise"><a href="#normalise" class="headerlink" title="normalise"></a>normalise</h4><p>函数原型：int normalise(x,y)</p><p>参数类型：big x,y</p><p>功能：y&#x3D;nx</p><p>返回值：n</p><h4 id="nroot"><a href="#nroot" class="headerlink" title="nroot"></a>nroot</h4><p>函数原型：BOOL <strong>nroot</strong>(x,n,z)</p><p>参数类型：big x,z; int n;</p><p>功能：$z&#x3D;\lfloor x^{1&#x2F;n} \rfloor$ </p><p>返回值；如果找到的根是精确的，则返回布尔值TRUE，否则返回FALSE。</p><h4 id="numdig"><a href="#numdig" class="headerlink" title="numdig"></a>numdig</h4><p>函数原型：int numdig(x)</p><p>参数类型：big x</p><p>功能：返回大数x中数字的个数（位数）</p><h4 id="otnum"><a href="#otnum" class="headerlink" title="otnum"></a>otnum</h4><p>函数原型：int otnum(x,f)</p><p>参数类型：flash x; FILE *f</p><p>功能：使用mirsys初始调用中指定的值作为基数，向屏幕或文件输出一个big或flash数字   如果实例变量RPOINT&#x3D;ON，则flash数字将转换为基数点表示。否则它将作为分数输出</p><p>返回值：输出字符数。</p><p>限制：mirsys中指定的基数必须小于或等于256。如果没有，请改用cotnum</p><h4 id="otstr"><a href="#otstr" class="headerlink" title="otstr"></a>otstr</h4><p>函数原型：int otstr(x,s)</p><p>参数类型：flash x; char *s</p><p>功能：将在对mirsys的初始调用中指定的值作为基数，向指定的字符串输出一个大big或flash数字   如果实例变量RPOINT&#x3D;ON，则flash数字将转换为基数点表示。否则它将作为分数输出</p><h4 id="premult"><a href="#premult" class="headerlink" title="premult"></a>premult</h4><p>函数原型：void premult(x,n,z)</p><p>参数类型：int n; big x,z</p><p>功能：z&#x3D;nx</p><h4 id="putdig"><a href="#putdig" class="headerlink" title="putdig"></a>putdig</h4><p>函数原型：void putdig(n,x,i)</p><p>参数类型：big x ; int i,n</p><p>功能：将一个大数的数字设置为给定值  ，n为新值</p><h4 id="remian"><a href="#remian" class="headerlink" title="remian"></a>remian</h4><p>函数原型：int remian(x,n)</p><p>参数类型：big x;int n</p><p>功能：当一个大数除以一个整数时，查找整数余数</p><p>返回值：余数</p><h4 id="set-io-buffer-size"><a href="#set-io-buffer-size" class="headerlink" title="set_io_buffer_size"></a>set_io_buffer_size</h4><p>函数原型：void set_io_buffer_size(len)</p><p>参数类型：int len</p><p>功能：设置输入&#x2F;输出缓冲区的大小。默认设置为1024，但需要处理非常大的数字的程序可能需要更大的I&#x2F;O缓冲区</p><h4 id="—void-set-user-function"><a href="#—void-set-user-function" class="headerlink" title="—void set_user_function"></a>—void set_user_function</h4><p>函数原型：void set_user_function(func)</p><p>参数类型：BOOL (*user)(void)</p><p>功能：提供一个用户指定的函数，该函数在一些比较耗时的MIRACL函数中定期调用，特别是那些涉及模幂运算和寻找大素数的函数</p><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>函数原型：int size(x)</p><p>参数类型：big x</p><p>功能：尝试将大数转换为简单整数。也可用于测试big&#x2F;flash变量的符号</p><h4 id="subdivisible"><a href="#subdivisible" class="headerlink" title="subdivisible"></a>subdivisible</h4><p>函数原型：BOOL subdivisible(x,n)</p><p>参数类型：big x;   int n;</p><p>功能： 测试n能否整除x</p><p>返回值: x除以n余数为0，返回TRUE，否则返回FALSE</p><h4 id="subtract"><a href="#subtract" class="headerlink" title="subtract"></a>subtract</h4><p>函数原型：void subtract(x,y,z)</p><p>参数类型：big x,y,z</p><p>功能：z&#x3D;x-y</p><h4 id="zero"><a href="#zero" class="headerlink" title="zero"></a>zero</h4><p>函数类型：void zero(x)</p><p>参数类型：flash x</p><p>功能：将x置零</p><h4 id="bigdig"><a href="#bigdig" class="headerlink" title="bigdig"></a>bigdig</h4><p>函数原型：void bigdig(n,b,x)</p><p>参数类型：int n,b  ;  big x</p><p>功能：产生一个指定长度的进制的随机数，该函数使用内置的随机数发生器，初始化种子调用irand函数</p><p>x是生成的大数  n位长   b是进制</p><p>eg</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">bigdig（<span class="hljs-number">100</span>,<span class="hljs-number">10</span>,x）；<br><span class="hljs-regexp">//</span>这将生成一个<span class="hljs-number">100</span>位十进制随机数<br></code></pre></td></tr></table></figure><h4 id="bigrand"><a href="#bigrand" class="headerlink" title="bigrand"></a>bigrand</h4><p>函数原型：void bigrand(w,x)</p><p>参数类型：big w,x;</p><p>功能：生成一个大的随机数。使用由irand初始化的内置简单随机数生成器，0&lt;&#x3D;x&lt;w</p><p>两个函数的区别：</p><p>两个函数都是可以生成随机数的，但是它们的功能确实略有差异的。bigrand()是产生一个小于w的大数随机数，x&lt;w，如果w是一个十位的十进制数，那么x可能是一个十位的十进制数，只有九位的十进制数，也可能使只有一位的十进制数；bigdig()是产生一个指定长度的进制的随机数，比如说指定了产生一个十位的十进制数，那么这个函数就会严格的产生一个十位的十进制数。</p><h4 id="egcd"><a href="#egcd" class="headerlink" title="egcd"></a>egcd</h4><p>函数原型：int egcd(x,y,z)</p><p>参数类型：big x,y,z;</p><p>功能：计算两个大数的最大公约数， <em>z&#x3D;gcd(x,y)</em></p><h4 id="expb2"><a href="#expb2" class="headerlink" title="expb2"></a>expb2</h4><p>函数原型：void expb2(n,x)</p><p>参数类型：  int n; big x;</p><p>功能：计算2的n次方的大数  <em>x&#x3D;2^n.</em></p><p>eg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">expb2(<span class="hljs-number">1398269</span>,x);   <span class="hljs-comment">//2^1398269</span><br>            decr(x,<span class="hljs-number">1</span>,x);        <span class="hljs-comment">//x = x - 1</span><br>            mip-&gt;IOBASE=<span class="hljs-number">10</span>;     <span class="hljs-comment">//使用10进制</span><br>            cotnum(x,<span class="hljs-built_in">stdout</span>);   <span class="hljs-comment">//输出到屏幕</span><br></code></pre></td></tr></table></figure><h4 id="expint"><a href="#expint" class="headerlink" title="expint"></a>expint</h4><p>函数原型：void expint（b, n, x）</p><p>参数类型：int b,n;  big x;</p><p>功能：计算b的n次方的大数  <em>x&#x3D;b^n.</em></p><h4 id="fft-mult"><a href="#fft-mult" class="headerlink" title="fft_mult"></a>fft_mult</h4><p>函数原型：void <strong>fft_mult</strong>(x,y,z)</p><p>参数类型：big x,y,z;</p><p>功能：使用Fast Fourier算法计算两个大数乘积，z&#x3D;x*y</p><h4 id="gprime"><a href="#gprime" class="headerlink" title="gprime"></a>gprime</h4><p>函数原型：void gprime(n)</p><p>参数类型：int n</p><p>功能：将达到某个限制的所有素数生成实例数组素数，并以零结尾</p><h4 id="hamming"><a href="#hamming" class="headerlink" title="hamming"></a>hamming</h4><p>函数原型：int hamming(n)</p><p>参数类型：big n</p><p>功能：计算一个大数的汉明权重–汉明距离（实际上是二进制表示中的1的数目）</p><h4 id="invers"><a href="#invers" class="headerlink" title="invers"></a>invers</h4><p>函数原型：unsigned int invers(x,y)</p><p>参数原型：unsigned int x,y;</p><p>功能：计算两个无符号整数（要求互素）的模逆，返回<em>x-1 mod y</em></p><h4 id="isprime"><a href="#isprime" class="headerlink" title="isprime"></a>isprime</h4><p>函数原型：BOOL isprime(x)</p><p>参数类型：big x;</p><p>功能：判断一个大数是否为素数，使用概率测试算法</p><p>返回值：x为素数返回TRUE，否则返回FALSE</p><h4 id="jac"><a href="#jac" class="headerlink" title="jac"></a>jac</h4><p>函数原型：int jac(x,n)</p><p>参数类型：unsigned int x,n;</p><p>功能：计算雅可比符号的值</p><h4 id="jack"><a href="#jack" class="headerlink" title="jack"></a>jack</h4><p>函数原型：int jack(x,n)</p><p>参数类型：big x,n</p><p>功能：计算雅可比符号的值</p><h4 id="logb2"><a href="#logb2" class="headerlink" title="logb2"></a>logb2</h4><p>函数原型：int logb2(x)</p><p>参数类型：big x;</p><p>功能： 计算一个大数（实际上是其中的位数）的基数2的近似整数log </p><h4 id="lucas"><a href="#lucas" class="headerlink" title="lucas"></a>lucas</h4><p>函数原型：void lucas(x,e,n,vp,v)</p><p>参数类型：big x,e,n,vp,v</p><p>功能：执行Lucas模幂运算。在内部使用蒙哥马利算法。通过调用特殊的汇编语言例程来实现Montgomery算法，可以为特定的模块进一步加速该函数。见powmod</p><h4 id="power"><a href="#power" class="headerlink" title="power"></a>power</h4><p>函数原型： void power(x,n,z,w)</p><p>参数类型： long n; big x,z,w;</p><p>功能：w&#x3D;xn.如果w≠z则w&#x3D;xn mod z</p><h4 id="powmod"><a href="#powmod" class="headerlink" title="powmod"></a>powmod</h4><p>函数原型：void powmod(x,y,z,w)</p><p>参数类型：big x,y,z,w;</p><p>功能：模幂运算，<em>w&#x3D;x^y mod z</em></p><h4 id="sfbit"><a href="#sfbit" class="headerlink" title="sfbit"></a>sfbit</h4><p>函数原型：void sftbit(x,n,z)</p><p>参数类型：big x,z;int n;</p><p>功能：将一个大数左移或右移n位，n为正数时左移，负数时右移</p><h4 id="xgcd"><a href="#xgcd" class="headerlink" title="xgcd"></a>xgcd</h4><p>函数原型：int xgcd(x,y,xd,yd,z)</p><p>参数类型： big x,y,xd,yd,z;</p><p>功能： 计算两个大数的扩展最大公约数，也可以用来计算模逆，这个函数比<strong>mad</strong> 函数运算速度稍慢。<em>z&#x3D;gcd(x,y)&#x3D;x.xd+y.yd</em></p><p>eg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">xgcd(x,p,x,x,x);  <span class="hljs-comment">//计算x^-1 mod p</span><br><span class="hljs-comment">/* x = 1/x mod p  (p is prime) *</span><br></code></pre></td></tr></table></figure><p><a href="https://wenku.baidu.com/view/1738a6878762caaedd33d4b4.html?sxts=1602327937928&amp;word=miracl%E5%BA%93%E6%89%8B%E5%86%8C">https://wenku.baidu.com/view/1738a6878762caaedd33d4b4.html?sxts=1602327937928&amp;word=miracl%E5%BA%93%E6%89%8B%E5%86%8C</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">xgcd(Mi1, m1, Mj1, Mj1, Mj1);<span class="hljs-comment">//Mj1为Mi1的逆</span><br>xgcd(Mi2, m2, Mj2, Mj2, Mj2);<span class="hljs-comment">//Mj2为Mi2的逆</span><br>xgcd(Mi3, m3, Mj3, Mj3, Mj3);<span class="hljs-comment">//Mj3为Mi3的逆</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//扩展的欧几里得算法</span><br><span class="hljs-comment">//Input</span><br>x = <span class="hljs-number">13</span><br>y = <span class="hljs-number">17</span><br>xgcd(x, y, xd, yd, z)<br><span class="hljs-comment">//Output</span><br>xd = <span class="hljs-number">4</span><br>yd = <span class="hljs-number">3</span><br>z = <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h4 id="实例变量IOBASE"><a href="#实例变量IOBASE" class="headerlink" title="实例变量IOBASE"></a>实例变量IOBASE</h4><p> IOBASE是用于控制输入和输出的进制问题的，可以在程序中随意更改， 必须大于或等于2且小于或等于256。使用实例是像这样的：mip-&gt;IOBASE&#x3D;16，这样子输入的变量和输出的变量所使用的进制都是十六进制</p>]]></content>
    
    
    <categories>
      
      <category>cryptography</category>
      
      <category>handbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cryptography</tag>
      
      <tag>skills</tag>
      
      <tag>miracl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客的搭建（hexo+github）</title>
    <link href="/2019/02/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/02/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h5 id="Hexo-中文官方网站-是一个快速-简洁且高效的博客框架-让上百个页面在几秒内瞬间完成渲染-Hexo支持Github-Flavored-Markdown的所有功能-甚至可以整合Octopress的大多数插件-并自己也拥有强大的插件系统"><a href="#Hexo-中文官方网站-是一个快速-简洁且高效的博客框架-让上百个页面在几秒内瞬间完成渲染-Hexo支持Github-Flavored-Markdown的所有功能-甚至可以整合Octopress的大多数插件-并自己也拥有强大的插件系统" class="headerlink" title="Hexo(中文官方网站)是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统."></a>Hexo(中文官方网站)是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统.</h5><span id="more"></span><h1 id="个人博客搭建过程（github-hexo）"><a href="#个人博客搭建过程（github-hexo）" class="headerlink" title="个人博客搭建过程（github hexo）"></a>个人博客搭建过程（github hexo）</h1><p>Hexo(中文官方网站)是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统.</p><hr><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>git下载（官网）</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://s2.ax1x.com/2019/02/24/k4Q7ff.png"></h5><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><h3 id="下载并安装（建议旧版）"><a href="#下载并安装（建议旧版）" class="headerlink" title="下载并安装（建议旧版）"></a>下载并安装（建议旧版）<img src="https://s2.ax1x.com/2019/02/24/k4l9hV.png"></h3><p>Tip：Custom Setup这一步，点一下Add to Path新建文件夹blog，右击git bash再点next</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>新建文件夹blog，右击git bash，输入以下</p><blockquote><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></blockquote><p>完成后输入</p><blockquote><p>cnpm i -g hexo-cli</p></blockquote><p>  检查hexo版本</p><blockquote><p>hexo  -v</p></blockquote><p><img src="https://s2.ax1x.com/2019/02/24/k4lFcF.png"></p><hr><h2 id="本地搭建博客"><a href="#本地搭建博客" class="headerlink" title="本地搭建博客"></a>本地搭建博客</h2><h3 id="依次输入以下命令"><a href="#依次输入以下命令" class="headerlink" title="依次输入以下命令"></a>依次输入以下命令</h3><blockquote><p>hexo init</p><p>cnpm install</p><p>hexo s <!--生成本地服务--></p></blockquote><h3 id="访问本地博客"><a href="#访问本地博客" class="headerlink" title="访问本地博客"></a>访问本地博客</h3><p>完成以上命令后，访问本地博客<a href="http://localhost:4000/">http://localhost:4000</a></p><p>如果以上步骤均无误，默认博客为以下页面，那么本地博客搭建完毕</p><p><img src="https://s2.ax1x.com/2019/02/24/k4lSkq.png"></p><hr><h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><h3 id="实现git本地管理GitHub"><a href="#实现git本地管理GitHub" class="headerlink" title="实现git本地管理GitHub"></a>实现git本地管理GitHub</h3><p>blog，右击git bash，进入输入如下地址</p><blockquote><p>git config –global user.name “你的github用户名”</p><p>git config –global user.email “你的邮箱”</p></blockquote><p>**tip  ** 注意空格！！！</p><h3 id="创建ssh"><a href="#创建ssh" class="headerlink" title="创建ssh"></a>创建ssh</h3><p> 打开git bash，依次输入</p><blockquote><p>ssh-keygen -t rsa -C your email</p><p>clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</p></blockquote><p>setting-&gt; 添加ssh key</p><p><img src="https://s2.ax1x.com/2019/02/24/k4lkX4.png"></p><p>粘贴密钥至key处（先得注册GitHub账号，需要翻墙注册，且新建的仓库名称要与github用户名对应）点击add ssh key</p><p>回到Gitbash 输入</p><blockquote><p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p></blockquote><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>创建新的储存库</p><p>进入blog文件夹，用编辑器打开，将最后的改成图中的样子（注意：冒号后有空格）</p><p><img src="https://s2.ax1x.com/2019/02/24/k4lPpT.png"></p><p>（其中为github的用户名）</p><h3 id="上传blog到GitHub"><a href="#上传blog到GitHub" class="headerlink" title="上传blog到GitHub"></a>上传blog到GitHub</h3><p>依次输入以下命令</p><blockquote><p>cnpm install hexo-deployer-git –save</p><p>hexo d</p></blockquote><p>现在可以通过   用户名.github.io   进入博客</p><hr><p>2021.10.8  <a href="https://hjxlog.com/posts/20190908a1.html#6-%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D">看到一个不错的博客（介绍如何搭建）</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
