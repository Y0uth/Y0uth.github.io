<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>隐私计算(2)-秘密共享</title>
    <link href="/2023/07/04/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%972-%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/"/>
    <url>/2023/07/04/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%972-%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>隐私计算(1)</title>
    <link href="/2023/07/04/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/07/04/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>本文以及系列文章根据陈凯、杨强老师撰写的《隐私计算》一书，系统的了解隐私计算相关技术和知识。</p><span id="more"></span><p>分为以下内容：</p><ul><li>秘密分享</li><li>同态加密</li><li>不经意传输</li><li>混淆电路</li><li>差分隐私</li><li>可信执行环境</li><li>联邦学习</li><li>隐私计算平台</li><li>隐私计算案例解析</li></ul><h3 id="1-隐私计算的定义和背景"><a href="#1-隐私计算的定义和背景" class="headerlink" title="1. 隐私计算的定义和背景"></a>1. 隐私计算的定义和背景</h3><p>根据隐私计算联盟和中国信息通信研究院云计算与大数据研究所与2021年7月发布的《隐私计算白皮书》中的定义，<strong>隐私计算是指在包志恒数据提供方不泄露原始数据的前提下，对数据进行分析计算的一系列技术，保障数据在流通和融合过程中“可用不可见”。</strong></p><p>隐私计算结合密码学、统计学、计算机体系结构和人工智能等学科，其理论和应用的发展与云计算、大数据和人工智能的发展密不可分。<strong>目前，隐私计算主要应用于数据查询和分析与机器学习两大任务中。</strong></p><ul><li>数据查询和分析：该类应用以计算任务为核心，包含各类查询、求和、求平均和方差等简单的运算。在此过程中，如何定义数据拥有方的数据隐私并对其进行保护，是隐私计算的重要研究课题。</li><li>机器学习：在机器学习模型训练的过程中，隐私计算需要对来自数据拥有方的训练数据隐私进行保护；在使用模型对新的数据进行推理时，隐私计算需要对该推理数据隐私进行保护。</li></ul><h3 id="2-隐私计算分类："><a href="#2-隐私计算分类：" class="headerlink" title="2.隐私计算分类："></a><strong>2.隐私计算分类：</strong></h3><p>按照历史发展过程、技术特点和隐私保护特征来看，隐私计算可以分为以基于密码学的安全协议为核心的<strong>隐私加密计算</strong>和外延含义更广的<strong>隐私保护计算</strong>。</p><ul><li>隐私加密计算。是指使用密码学工具在安全协议层次构建隐私计算协议，从而实现多个数据拥有方在相互保护隐私的前提下，协同完成计算任务。<strong>此类技术的代表为安全多方计算</strong>。隐私加密技术拥有严格的安全证明保证隐私的密码学等级安全，但是由于密码学工具算法具有较高的复杂性，在实践中也非常低效。随着秘密共享、不经意传输、混淆电路和同态加密等密码学工具的不断发展，隐私加密技术仍然有广泛的适用场景和发展潜力。</li><li>隐私保护技术。为了在计算任务中对隐私进行更加细分的分析和控制，隐私计算的研究逐渐脱离出隐私加密计算的密码学范畴，在更加广泛的技术和应用场景下研究计算前对数据的安全获取和管理、计算过程中对数据隐私的保护，以及计算完成后对生成数据隐私的保护和相关权属与利益的分配，将这一系列新的隐私计算技术成为隐私保护计算。按照这些技术基于的研究发展轨迹、算法基础和应用特点，<strong>可以分为差分隐私、可信执行环境和联邦学习三种技术。</strong></li></ul><h3 id="3-隐私计算的发展历程"><a href="#3-隐私计算的发展历程" class="headerlink" title="3.隐私计算的发展历程"></a>3.隐私计算的发展历程</h3><p>现代隐私计算技术发展历程大致可以分为四个阶段：</p><p><strong>第一阶段是安全多方计算理论和应用的发展。</strong>安全多方计算使用密码学工具构建了一个安全的计算模型，使得多个参与方可以使用自己的数据进行协作计算，同时保证自己的数据不泄露给其他参与方。其主要问题是性能与明文计算相比相差太大，最差情况可比明晚计算慢6个数量级，具体开销取决于计算与网络环境，<u>其主要的性能瓶颈在于大量增加的通信开销。</u></p><p><strong>第二阶段是差分隐私的理论和应用。</strong>差分隐私对计算过程和计算结果增加随机扰动，从而对个体数据进行混淆。不同于密码学理论论证破解难度来证明安全，差分隐私基于增加噪声带来的数据概率分布的混淆，在更加灵活的层面上评估自身的隐私保护能力。</p><p><strong>第三阶段是以可信执行环境和全同态加密为代表的集中加密计算</strong>。与前两个阶段的思路不同的是，该阶段希望找到一个让数据安全地离开本地的方法。</p><ul><li>其中一条路线是可信执行环境，其创造了一个隔离的运行环境，用户可以将自己的数据上传到可信执行环境中，而不必担心自己的数据被其他程序或者计算设备的管理者窃取。<u>可信执行环境的实现依赖于厂商的特定硬件</u>，例如Inter SGX、ARM TrustZone等，因此其安全性并不能够得到十分的保障，但其性能与明文直接计算相似，比同态加密更具实用性。</li><li>另一条技术路线是同态加密，同态加密使得我们可以在密文上直接计算得到有效的结果，不需要先解密再运算。<u>同态加密需要付出额外的通信代价</u>，这是将数据加密后进行传输产生的通信代价。另外，<u>同态加密也带来了很大的额外计算代价</u>，通常比明文计算慢6个数量级。</li></ul><p><strong>第四阶段是针对近似建模计算任务（例如机器学习建模和预测）设计的联邦学习</strong>。与以往的技术思路不同的是，联邦学习让各数据拥有方本地保存模型与数据，只在各方之间进行<strong>经过保护的参数信息的传递</strong>来完成训练过程。与传统的集中式机器学习相比，联邦学习的性能代价主要在于密文计算和传输中间结果产生的额外通信。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230704165222072.png" alt="image-20230704165222072"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Privacy-Preserving Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>演化算法</title>
    <link href="/2023/06/27/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/27/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>遗传算法（Genetic Algorithm，GA）最早是由美国的 John holland于20世纪70年代提出,该算法是根据大自然中生物体进化规律而设计提出的。是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。</p><span id="more"></span><h3 id="1-遗传算法概述"><a href="#1-遗传算法概述" class="headerlink" title="1. 遗传算法概述"></a>1. 遗传算法概述</h3><p>遗传算法由John H.Holland教授提出，为一种全局优化算法。它模拟自然进化与遗传理论，通过将优化问题进行转移，从而成功避免了一般优化算法中需要过多考虑的动力学信息问题，在原理上突破了常规的优化算法框架，算法结构较简单、处理信息能力较强，具有很好的鲁棒性。遗传算法最大的特点就是将优化问题中的参数转换成了编码的个体，从而不需要管理优化问题中的参数问题，只需要处理进行了编码的个体，而这些个体在遗传算法优化过程中所描述的就是生物界中“物竞天择，适者生存”的生存抉择概念。正是由于遗传算法具有上述等特点，现在被广泛用于各大领域，比如在一些优化问题复杂多样以及非线性等问题上，是21世纪以来智能算法中的比较突出的技术之一。</p><p><strong>核心思想：</strong></p><ul><li>遗传算法是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法</li><li>遗传算法起源于对生物系统所进行的计算机模拟研究。模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解</li><li>遗传算法遵循自然界<code>适者生存、优胜劣汰</code>的原则，是一类借鉴生物界自然选择和自然遗传机制的随机化搜索算法</li></ul><p>达尔文进化论的主要观点是：物竞天择，适者生存。遗传算法的基本思想就是模仿自然进化过程，通过对群体中具有某种结构形式的个体进行遗传操作，从而生成新的群体，逐渐逼近最优解。在求解过程中设定一个固定规模的种群，种群中的每个个体都表示问题的一个可能解，个体适应环境的程度用适应度函数判断，适应度差的个体被淘汰，适应度好的个体得以继续繁衍，繁衍的过程中可能要经过选择、交叉、变异，形成新的族群，如此往复得到更多更好的解。</p><h3 id="2-遗传算法基本概念"><a href="#2-遗传算法基本概念" class="headerlink" title="2. 遗传算法基本概念"></a>2. 遗传算法基本概念</h3><ol><li>基因（Gene）：是生物界中表现生物体性状特征的一种遗传因子。在遗传算法中，基因的表示方法常常采用二进制（1 0）、整数或者某种字符来进行表达。</li><li>染色体（Chromosome）：是生物界中的生物体表现遗传类特征的一种物质，也就是说它是基因存储的一种载体。</li><li>个体（Individual）：个体所表现出来的是生物体带有特征的实体。在遗传算法进行遗传优化的过程中所优化的基本对象就是个体。</li><li>种群（Population）：个体的集合称为种群。</li><li>群体规模（Population Size）：群体规模表示的是整个种群中所有的个体数量总和。</li><li>适应度（Fitness）：是个体优良的参考值。</li><li>编码（Coding)：DNA中的遗传信息是按某种方式陈列在一个长链上。在遗传算法中，这实际上是一个映射过程，即先验参数到遗传参数的映射。</li><li>选择（Selection)：描述的是“物竞天择，适者生存”的概念。在遗传算法中，参考个体适应值进行选择的过程。</li><li>复制（Reproduction）：即DNA复制。在遗传算法中，对个体进行选择时，往往会根据群体规模来进行优良个体的复制。</li><li>交叉（Crossover）：即杂交，是两个同源染色体在配对时，相互交换基因的过程。在遗传算法中，表示的是两个随机选择的个体进行信息互换的过程。</li><li>变异（Mutation）：细胞在进行复制的时候，会出现很小的概率的差错，使得子染色体与母染色体不同，即发生变异。在遗传算法中，随机性的对个体中的信息进行改变的过程。</li></ol><h3 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h3><p>基本遗传算法(也称标准遗传算法或简单遗传算法，Simple Genetic Algorithm，简称SGA)是一种群体型操作，该操作以群体中的所有个体为对象，只使用基本遗传算子(Genetic Operator)：<strong>选择算子(Selection Operator)<strong>、</strong>交叉算子(Crossover Operator)<strong>和</strong>变异算子(Mutation Operator)<strong>，其遗传进化操作过程简单，容易理解，是其它一些遗传算法的基础，它不仅给各种遗传算法提供了一个基本框架，同时也具有一定的应用价值。</strong>选择</strong>、<strong>交叉</strong>和<strong>变异</strong>是遗传算法的3个主要操作算子，它们构成了遗传操作，使遗传算法具有了其它方法没有的特点。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230627212322571.png" alt="image-20230627212322571"></p><p><strong>1） 编码和产生初始群体</strong></p><p>根据优化函数的实际问题，选择好相应的编码方法，根据种群规模的需要，随机产生确定长度的n个染色体，作为初始种群。<br>$$<br>pop_i(t),i&#x3D;1,2,3,…,n<br>$$<br><strong>2）计算适应度值</strong></p><p>假设适应度函数为$f(i)$，则对所有的个体计算其相对应的值为：<br>$$<br>f(i)&#x3D;f(pop_i(t))<br>$$<br><strong>3）终止判断</strong></p><p>根据设定的终止条件判断是否达到收敛状态以选择下一步操作。</p><p><strong>4）选择运算</strong></p><p>选择适应度值大的个体进行交叉运算，则每个个体的选择概率为<br>$$<br>P_i&#x3D;\frac{f(i)}{\sum_{i&#x3D;1}^n  f(i)},i&#x3D;1,2,…,n<br>$$<br>以选择概率$P_i$作为新的概率分布，从当前种群中选择个体重组新的个体种群：<br>$$<br>newpop(t+1)&#x3D;{pop_j(t)|j&#x3D;1,2,3,…,n}<br>$$<br><strong>5）交叉运算</strong></p><p>随机从种群中选择两个不同的个体，以概率$P_c$进行交换基因，得到新的两个个体，进行<em>n</em>&#x2F;2次，得到一个新的种群$crosspop(t+1)$。</p><p><strong>6）变异运算</strong></p><p>从种群中随机选择个体，以变异概率$P_m$进行染色体变异，得到新的种群$mutpop(t+1)$,这个群体作为完成一次遗传操作的子种群，即$pop(t)&#x3D;mutpop(t+1)$,此时传到第 2）步。</p><h3 id="4-实验实现GA算法"><a href="#4-实验实现GA算法" class="headerlink" title="4. 实验实现GA算法"></a>4. 实验实现GA算法</h3><p>实验环境：windows 10、python 3.7、pycharm 2018</p><p><strong>使用算法求解函数$f(x)&#x3D;\sum_{i&#x3D;1}^{29}[100(x_{i+1}-x_i^2)^2+(x_i-1)^2] ,-30 \le x_i \le30 \$  和函数$f(x)&#x3D;-\sum_{i&#x3D;1}^{30}(x_isin(\sqrt{\lvert{x_i}\lvert})),-500\le x_i \le 500$的最小值</strong></p><p><strong>算法实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 定义函数 f1(x)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-number">100</span> * (x[i+<span class="hljs-number">1</span>] - x[i]**<span class="hljs-number">2</span>)**<span class="hljs-number">2</span> + (x[i] - <span class="hljs-number">1</span>)**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">29</span>))<br><br><span class="hljs-comment"># 定义函数 f2(x)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> -<span class="hljs-built_in">sum</span>(x[i] * np.sin(np.sqrt(<span class="hljs-built_in">abs</span>(x[i]))) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>))<br><br><span class="hljs-comment"># 生成一个个体</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_individual</span>(<span class="hljs-params">problem, bounds</span>):<br>    <span class="hljs-keyword">if</span> problem == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果是问题1</span><br>        <span class="hljs-keyword">return</span> [random.uniform(-<span class="hljs-number">30</span>, <span class="hljs-number">30</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>)]  <span class="hljs-comment"># 则每个元素在(-30, 30)之间随机取值</span><br>    <span class="hljs-keyword">elif</span> problem == <span class="hljs-number">2</span>:  <span class="hljs-comment"># 如果是问题2</span><br>        <span class="hljs-keyword">return</span> [random.uniform(-<span class="hljs-number">500</span>, <span class="hljs-number">500</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>)]  <span class="hljs-comment"># 则每个元素在(-500, 500)之间随机取值</span><br><br><span class="hljs-comment"># 计算个体的适应度值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fitness</span>(<span class="hljs-params">individual, problem</span>):<br>    <span class="hljs-keyword">if</span> problem == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果是问题1</span><br>        <span class="hljs-keyword">return</span> f1(individual)  <span class="hljs-comment"># 则计算函数f1的值</span><br>    <span class="hljs-keyword">elif</span> problem == <span class="hljs-number">2</span>:  <span class="hljs-comment"># 如果是问题2</span><br>        <span class="hljs-keyword">return</span> f2(individual)  <span class="hljs-comment"># 则计算函数f2的值</span><br><br><span class="hljs-comment"># 选择父代个体</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">selection</span>(<span class="hljs-params">population, fitness_values</span>):<br>    parents = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):  <span class="hljs-comment"># 选择2个父代个体</span><br>        tournament_indices = [random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(population) - <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># 随机选择5个个体</span><br>        best_index = <span class="hljs-built_in">min</span>(tournament_indices, key=<span class="hljs-keyword">lambda</span> i: fitness_values[i])  <span class="hljs-comment"># 选出适应度值最小的个体</span><br>        parents.append(population[best_index])  <span class="hljs-comment"># 将最佳个体加入父代列表中</span><br>    <span class="hljs-keyword">return</span> parents<br><br><span class="hljs-comment"># 交叉操作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crossover</span>(<span class="hljs-params">parents</span>):<br>    crossover_point = random.randint(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(parents[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 随机选择交叉点</span><br>    child1 = parents[<span class="hljs-number">0</span>][:crossover_point] + parents[<span class="hljs-number">1</span>][crossover_point:]  <span class="hljs-comment"># 生成子代1</span><br>    child2 = parents[<span class="hljs-number">1</span>][:crossover_point] + parents[<span class="hljs-number">0</span>][crossover_point:]  <span class="hljs-comment"># 生成子代2</span><br>    <span class="hljs-keyword">return</span> child1, child2<br><br><span class="hljs-comment"># 变异操作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mutation</span>(<span class="hljs-params">individual, bounds, mutation_rate</span>):<br>    mutated = individual.copy()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(mutated)):<br>        <span class="hljs-keyword">if</span> random.random() &lt; mutation_rate:  <span class="hljs-comment"># 以mutation_rate的概率进行变异</span><br>            mutated[i] = random.uniform(bounds[i][<span class="hljs-number">0</span>], bounds[i][<span class="hljs-number">1</span>])  <span class="hljs-comment"># 在元素的取值范围内随机取值</span><br>    <span class="hljs-keyword">return</span> mutated<br><br><span class="hljs-comment"># 遗传算法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">genetic_algorithm</span>(<span class="hljs-params">problem, bounds, pop_size=<span class="hljs-number">800</span>, generations=<span class="hljs-number">1000</span>, mutation_rate=<span class="hljs-number">0.01</span></span>):<br>    population = [generate_individual(problem, bounds) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pop_size)]  <span class="hljs-comment"># 生成初始种群</span><br>    best_fitnesses = []<br><br>    <span class="hljs-keyword">for</span> generation <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(generations):  <span class="hljs-comment"># 进行generations代的迭代</span><br>        fitness_values = [fitness(ind, problem) <span class="hljs-keyword">for</span> ind <span class="hljs-keyword">in</span> population]  <span class="hljs-comment"># 计算种群中每个个体的适应度值</span><br>        new_population = []<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(new_population) &lt; pop_size:  <span class="hljs-comment"># 生成新的种群，直到种群数量达到pop_size</span><br>            parents = selection(population, fitness_values)  <span class="hljs-comment"># 选择父代个体</span><br>            child1, child2 = crossover(parents)  <span class="hljs-comment"># 交叉操作生成2个子代</span><br>            child1 = mutation(child1, bounds, mutation_rate)  <span class="hljs-comment"># 对子代1进行变异</span><br>            child2 = mutation(child2, bounds, mutation_rate)  <span class="hljs-comment"># 对子代2进行变异</span><br>            new_population.extend([child1, child2])  <span class="hljs-comment"># 将2个子代加入新的种群中</span><br><br>        population = new_population  <span class="hljs-comment"># 更新种群</span><br><br>        best_fitness = <span class="hljs-built_in">min</span>(fitness_values)  <span class="hljs-comment"># 当前最佳适应度值</span><br>        best_fitnesses.append(best_fitness)  <span class="hljs-comment"># 将当前最佳适应度值加入列表中</span><br><br>    best_individual = <span class="hljs-built_in">min</span>(population, key=<span class="hljs-keyword">lambda</span> ind: fitness(ind, problem))  <span class="hljs-comment"># 选出适应度值最小的个体作为最佳个体</span><br><br>    <span class="hljs-comment"># 绘制适应度值随迭代次数变化的曲线</span><br>    plt.plot(<span class="hljs-built_in">range</span>(generations), best_fitnesses)<br>    plt.xlabel(<span class="hljs-string">&quot;Generation&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Fitness&quot;</span>)<br>    plt.title(<span class="hljs-string">f&quot;Problem <span class="hljs-subst">&#123;problem&#125;</span>&quot;</span>)<br>    plt.show()<br><br>    <span class="hljs-keyword">return</span> fitness(best_individual, problem), best_individual<br><br>bounds1 = [(-<span class="hljs-number">30</span>, <span class="hljs-number">30</span>)] * <span class="hljs-number">30</span>  <span class="hljs-comment"># 问题1中每个元素的取值范围</span><br>bounds2 = [(-<span class="hljs-number">500</span>, <span class="hljs-number">500</span>)] * <span class="hljs-number">30</span>  <span class="hljs-comment"># 问题2中每个元素的取值范围</span><br><br>min_f1, best_individual1 = genetic_algorithm(<span class="hljs-number">1</span>, bounds1)  <span class="hljs-comment"># 求解问题1的全局最小值</span><br>min_f2, best_individual2 = genetic_algorithm(<span class="hljs-number">2</span>, bounds2)  <span class="hljs-comment"># 求解问题2的全局最小值</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Minimum value of f1(x):&quot;</span>, min_f1)  <span class="hljs-comment"># 输出问题1的全局最小值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Best individual for f1(x):&quot;</span>, best_individual1)  <span class="hljs-comment"># 输出问题1的最佳个体</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Minimum value of f2(x):&quot;</span>, min_f2)  <span class="hljs-comment"># 输出问题2的全局最小值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Best individual for f2(x):&quot;</span>, best_individual2)  <span class="hljs-comment"># 输出问题2的最佳个体</span><br></code></pre></td></tr></table></figure><p><strong>实验结果：</strong></p><p>与函数真实的全局最小值很接近：</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230704110237331.png" alt="image-20230704110237331"></p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230627214207483.png" alt="image-20230627214207483"></p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230627214300498.png" alt="image-20230627214300498"></p><h3 id="5-遗传算法的优缺点"><a href="#5-遗传算法的优缺点" class="headerlink" title="5. 遗传算法的优缺点"></a>5. 遗传算法的优缺点</h3><p><strong>遗传算法的优点</strong></p><ul><li>如果处理得当，可以在优化问题中得到全局最优解</li><li>比较容易实现并行化计算</li><li>遗传算法以结果为导向，最关注的两个点，一是编码与解码，一是适应度函数。它需要的背景知识少，也不需要太关注过程。所以应用范围非常广，可以解决非线性、不连续的问题，甚至有些无法清晰知道过程的问题，也可以解决</li></ul><p><strong>遗传算法的缺点</strong></p><ul><li>遗传算法非常依赖适应度函数，可以说适应度函数直接确定了结果的走向，而这个函数需要使用者自行提供，而且还没有标准，需根据实现问题总结出来</li><li>群体大小选择不当，或者选择压设置不对，都可能会过早收敛，错过全局最优解，只能达到局部最优解</li><li>因为遗传算法并不太关注过程，所以计算过程中的参数稍有不同可能会得到不同结果。这些参数包括群体大小、交换频率、突变频率等</li><li>当染色体过长(即基因数过多)时，需要重组的片段更多，导致群体规模非常大，使计算时间急剧增加</li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BP算法</title>
    <link href="/2023/06/26/BP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/26/BP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>BP算法是由学习过程由信号的正向传播与误差的反向传播两个过程组成。由于多层前馈网络的训练经常采用误差反向传播算法，人们也常把将多层前馈网络直接称为BP网络。</p><span id="more"></span><h3 id="1-人工神经元"><a href="#1-人工神经元" class="headerlink" title="1. 人工神经元"></a>1. 人工神经元</h3><p>神经网络中最基本的成分是神经元(neuron)模型，在生物神经网络中，每个神经元与其他神经元相连，当 它 “兴奋”时, 就会向相连的神经元发送化学物质，从而改变这些神经元内的电位；如果某神经元的电位超过了一个“阈值”(threshold)，那么它就会被激活，即 “兴奋” 起来，向其他神经元发送化学物质。</p><p>1943 [McCulloch and Pitts, 1943]将上述情形抽象为如下图所示的简单模型，这就是一直沿用至今的“M -P 神经元模型”。在这个模型中，神经元接 收到来自几个其他神经元传递过来的输入信号，这些输入信号通过带权重的连 接(connection)进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过“激活函数”(activation function)处理以产生神经元的输出。把许多个这样的神经元按一定的层次结构连接起来，就得到了神经网络。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230626162520176.png" alt="image-20230626162520176"></p><p>图中$x_i \sim x_n$是从其他神经元传来的输入信号，$w_{ij}$表示从神经元$j$到神经元$i$的连接权值，$\theta$表示一个阈值，那么神经元$i$的输出与输入的关系表示为<br>$$<br>net_i&#x3D;\sum_{j&#x3D;1}^nw_{ij}x_j-\theta<br>$$</p><p>$$<br>y_i&#x3D;f(net_i)<br>$$</p><p>式中$y_i$表示神经元$i$的输出，函数f成为<code>激活函数</code>或转移函数。如果将阈值看成是神经元$i$的一个输入$x_0$的权重$w_{i0}$，则上述公式可以简化为<br>$$<br>net_i&#x3D;\sum_{j&#x3D;0}^n w_{ij}x_j<br>$$<br>选择的激活函数不同，$y_i$的取值范围也不同，而函数f通常要求选择可微的函数，通常选择Sigmoid函数<br>$$<br>sigmoid function：f(x)&#x3D;\frac{1}{1+e^{-x}}<br>$$<br>函数图像如下所示。该函数具有以下特性：非线性、单调性、无限次可微，并且当权值很大时可近似阈值函数，当权值很小时可近似线性函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230627102707493.png" alt="image-20230627102707493"></p><h3 id="2-前馈神经网络"><a href="#2-前馈神经网络" class="headerlink" title="2. 前馈神经网络"></a>2. 前馈神经网络</h3><p>构成前馈神经网络的神经元接受前一级输入，并输出到下一级，无反馈。其节点分为两类:输入节点与计算单元。每个计算单元可有任意个输入，但只有一个输出，而输出可耦合到任意多个其他节点的输入。前馈网络通常分为不同的层，第$i$层的输入只与第$i–1$层的输出相联。输入节点为第一层。输入和输出节点由于可与外界相连，称为可见层，而其他的中间层则称为隐藏层。而其中三层前馈网络又是其特例，三层前馈网络由输入层、中间层和输出层构成，有两个计算层，也称三层感知器，能够求解非线性问题。三层或三层以上的前馈网络通常又被叫做多层感知器(Multi-Layer Perceptron，简称MLP)，由三部分组成：一组感知单元组成输入层；一层或多层计算节点的隐藏层；一层计算节点的输出层。多层感知器的表示：输入节点数-第1隐层节点数-第⒉隐层节点数-…-输出节点数。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230627154520676.png" alt="image-20230627154520676"></p><p>当使用阈值函数作为神经元输出函数时，任何逻辑函数都可以使用一个三层的前馈网络实现。当神经元的输出函数为Sigmoid函数时,上述结论可以推广到连续的非线性函数。在很宽松的条件下，三层前馈网络可以逼近任意的多元非线性函数，突破了二层前馈网络线性可分的限制。</p><p>要使神经元合理的组合输出，需要先让其学习以模拟生物的学习过程。神经元的学习算法通常采用Hebb学习规则，如果神经元$u_i$接收来自另一神经元$u_j$的输出，则当这两个神经元同时兴奋时，从$u_j$到$u_i$;的权值$w_{ij}$就得到加强。具体到前述的神经元模型，可以将Hebb规则表现为如下的算法$\Delta w_i&#x3D;\eta yx_i$。式中$\Delta w_i$是对第$i$个权值的修正量，$\eta$是控制学习速度的系数。太大会影响训练的稳定性，太小则使训练的收敛速度变慢，一般取$0&lt;\eta≤1$，人工神经网络首先要以一定的学习准则进行学习，然后才能工作。</p><h3 id="3-BP算法"><a href="#3-BP算法" class="headerlink" title="3. BP算法"></a>3. BP算法</h3><p>三层前馈网络的适用范围大大超过二层前馈网络，但学习算法较为复杂，主要困难是中间的隐藏层不直接与外界连接，无法直接计算其误差。而BP算法可解决这一问题。其<strong>主要思想是从后向前(反向)逐层传播输出层的误差，以间接算出隐藏层误差。</strong>因此算法分为两个阶段:</p><ul><li>第一阶段(正向传导过程)：输入信息从输入层经隐藏层逐层计算各单元的输出值;</li><li>第二阶段(反向传播过程)：输出误差逐层向前算出隐藏层各单元的误差，并用此误差修正前层权值。</li></ul><p>在反向传播算法中通常采用梯度法修正权值，为此要求输出函数可微，通常采用Sigmoid函数作为输出函数。下面考虑一个三层前馈网络，其中$i$表示前层第$i$个单元，$k$表示后层第$k$个单元，$O_j$表示本层的输出，$w_{ij}$表示前层到本层的权值，$w_{jk}$表示本层到后层的权值。其中的输出函数选择Sigmoid函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230626165418477.png" alt="image-20230626165418477"></p><p>第一阶段的正向传导过程中，第$j$层的输入如此按公式所述，第一阶段从输入层逐层往后计算输出，直到最后一层。<br>$$<br>net_j&#x3D;\sum_{i&#x3D;0}^nw_{ij}O_i<br>$$</p><p>$$<br>O_j&#x3D;f(net_j)&#x3D;\frac{1}{1+e^{-net_j}}<br>$$</p><p>第二阶段的反向传播过程中，对于输出层，$O_k$是实际输出，与理想输出$y_k$的均方误差可以通过以下公式计算。<br>$$<br>E&#x3D;\frac{1}{2}\sum_k(y_k-O_k)^2<br>$$<br>输出层的局部梯度为：<br>$$<br>\delta_j&#x3D;\frac{\partial E}{\partial \ net_j}&#x3D;\frac{\partial E}{\partial \  out_j}\frac{\partial\ out_j}{\partial \ net_j  }&#x3D;-(y_j-O_j)O_j(1-O_j)<br>$$<br>因此计算权值对误差的影响如下公式所示<br>$$<br>\frac{\partial E}{\partial \  w_{ij}}&#x3D;\frac{\partial E}{\partial \ net_j}\frac{\partial \ net_j}{\partial \ w_{ij}}&#x3D;\delta_jO_j<br>$$<br>采用负梯度修正权值，<br>$$<br>w&#x3D;w-\delta ·O<br>$$<br>BP算法易形成局部极小而得不到全局最优，训练次数多使得学习效率低，存在收敛速度慢等问题。</p><p>传统的BP算法改进主要有两类：</p><ul><li>启发式算法：如附加动量法，自适应算法。</li><li>数值优化算法：如共轭梯度法、牛顿迭代法等。</li></ul><p><strong>算法流程：</strong></p><p><u>对每个训练样例,</u>，BP算法执行以下操作：先将输入示例提供给输入层神经元，然后逐层将信号前传，直到产生输出层的结果；然后计算输出层的误差(第4-5行)，再将误差逆向传播至隐层神经元(第6行)，最后根据隐层神经元的误差来对连接权和阈值进行调整(第7行)。该迭代过程循环进行，直到达到某些停止条件为止，例如训练误差已达到一个很小的值。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230626224501429.png" alt="image-20230626224501429"></p><p>但我们上面介绍的“标准BP算法”<strong>每次仅针对一个训练样例更新连接权和阈值</strong>，也就是说，图中算法的更新规则是基于单个的$E_k$推导而得。如果类似地推导出基于累积误差最小化的更新规则，就得到了<strong>累积误差逆传播(accumulated error backpropagation)算法</strong>。累积BP算法与标准BP算法都很常用。一般来说,标准BP算法每次更新只针对单个样例，参数更新得非常频繁，而且对不同样例进行更新的效果可能出现“抵消”现象。因此，为了达到同样的累积误差极小点，标准BP算法往往需进行更多次数的迭代。<strong>累积BP算法直接针对累积误差最小化，<u>它在读取整个训练集D一遍后才对参数进行更新</u>，其参数更新的频率低得多。</strong>但在很多任务中,累积误差下降到一定程度之后,进一步下降会非常缓慢，这时标准BP往往会更快获得较好的解，尤其是在训练集D非常大时更明显。 </p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c回炉重造</title>
    <link href="/2023/06/06/c%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0/"/>
    <url>/2023/06/06/c%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<p>好久没写代码了，打算重新对C进行学习，把自己忘记的一些点记录一下， 应该会有一些新的理解和认识。</p><span id="more"></span><h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p><code>编译器</code>是将高级语言程序翻译成计算机能理解的机器语言指令集的程序。使用合适的编译器或者编译器集，便可以把一种高级语言程序转换成供各种不同类型CPU使用的机器语言程序。</p><p>编程机制：c编程的基本策略是，用程序将<strong>源代码文件转换成可执行文件</strong>（其中包含可直接运行的机器语言代码）。典型的c实现通过<strong>编译</strong>和<strong>链接</strong>两个步骤来完成这一步的。编译器把源代码转换成中间代码，链接器把中间代码和其他代码合并，生成可执行文件。</p><p><code>中间文件</code>有多种形式，最普遍的一种形式是将源代码转换成机器语言代码，并将结果放在<code>目标代码文件</code>中，目标代码文件虽然包含机器语言代码，但是不能直接运行该文件，因为目标文件中存储的是编译器翻译的源代码，还不是一个完整的程序。</p><p>目标文件代码缺少启动代码。启动代码充当程序和操作系统之间的接口。目标代码还缺少库函数。链接器的作用是，将编写的目标代码、系统的标准启动代码和可代码这三部分文件合并成一个文件，即可执行文件。</p><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>char类型用于存储字符，但是实际上存储的是整数（例如ASCII码）而不是字符</p><p>c语言把<u>1字节</u>定义为char类型占用的位数（bits）</p><p>用单引号括起来的单个字符被称为<code>字符常量</code>，双引号括起来的被认为是<code>字符串</code></p><p>c语言没有专门用于存储字符串的变量类型，字符串被存储在char类型的数组中。</p><p>c语言中所有的非零值都视为真</p><hr><p>ios646.h</p><blockquote><p>and &#x3D; &amp;；or&#x3D;||；not&#x3D;!</p></blockquote><p>ctype.h</p><blockquote><p>issapce()、isalpha()……</p></blockquote><p>getchar()和putchar()读取文件检测到文件结尾时将会返回一个特殊的值，即EOF&#x3D;-1</p><hr><h3 id="字符输入-x2F-输出"><a href="#字符输入-x2F-输出" class="headerlink" title="字符输入&#x2F;输出"></a>字符输入&#x2F;输出</h3><p>重定向输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">echo_eof &lt; words<br></code></pre></td></tr></table></figure><p>&lt;是Unix和Dos&#x2F;Windows的重定向运算符，该运算符使words文件与stdin流关联，把文件中的内容导入echo_eof程序。echo_eof程序本身并不知道（或不关心）输入的内容来自文件还是键盘，它只知道这是需要导入的字符流</p><p>重定向输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">echo_eof &gt; mywords<br></code></pre></td></tr></table></figure><p>将echo_eof的输出重定向到mywords文件中</p><p>混合使用getchar()和putchar()，如果在调用getchar()之前，scanf()在输入行留下一个换行符，会导致一些问题。</p><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>指针是一个值为内存地址的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> * pi;<br><span class="hljs-type">char</span> * pc;<br><span class="hljs-type">float</span> * pf;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lifeID</title>
    <link href="/2023/06/03/lifeID/"/>
    <url>/2023/06/03/lifeID/</url>
    
    <content type="html"><![CDATA[<p>An open-source, blockchain-based platform for self-sovereign identity</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>身份盗用愈演愈烈</li><li>身份管理使用广泛且频繁</li></ul><p>lifeID 基金会的使命是为每个人提供终身的、自主的数字身份，这将被称为一个人的“lifeID”。有了自我主权的数字身份，每个人都可以安全、轻松地管理所有需要身份验证的在线和现实世界交易，而无需依赖大型社交网络、公司或政府机构的第三方监督或控制。</p><p>lifeID 旨在为用户提供与来自 Facebook 或 Google 登录的单点登录 (SSO) 相同的便利，<strong>但没有社交媒体登录伴随的许多风险和潜在的隐私侵犯</strong>。同样重要的是，它消除了个人身份信息 (PII) 被企业数据巨头货币化和出售以获取商业利益的可能性。它还消除了那些相同的公司实体因官僚主义的想法而拒绝访问的风险。</p><p>lifeID 将被构建为一个开放、无需许可且高度安全的基于区块链的身份服务，称为 lifeID 平台。该平台将由自我维持、自筹资金的 lifeID 基金会部署和管理，lifeID 基金会是区块链生态系统的身份即服务 (IDaaS) 层，支持各种身份特定交易。</p><h2 id="Identity-is-broken"><a href="#Identity-is-broken" class="headerlink" title="Identity is broken"></a>Identity is broken</h2><ul><li><p>身份管理是一项艰巨的任务</p></li><li><p>当前的选项具有实际成本</p><blockquote><p>管理密码任务艰巨-&gt;不愿注册新用户、忘记密码</p><p>单点登录：黑客破解程序并快速获取用户数据</p></blockquote></li><li><p>社交媒体用户无法控制自己的身份 </p><blockquote><p>Facebook、谷歌、LinkedIn 等科技巨头控制着身份数据——而不是用户。这些公司不对用户负责。他们可以随时出于任何原因拒绝访问，并且不需要提供解释或追索权。</p></blockquote></li><li><p>私有的、集中的身份平台不安全</p></li><li><p>在线世界和现实世界之间没有联系</p><blockquote><p>在现实世界中，实体环境中，在线登录没有用，迫使消费者随身携带装满物理 ID 的钱包，如健身房会员资格、驾照、门禁卡等。</p></blockquote></li></ul><h2 id="Solving-identity-management-with-self-sovereign-identity"><a href="#Solving-identity-management-with-self-sovereign-identity" class="headerlink" title="Solving identity management with self-sovereign identity"></a>Solving identity management with self-sovereign identity</h2><ul><li><p>控制</p><blockquote><p>基本要素是消费者拥有并控制所有适用的身份数据,此外，任何公司或政府机构都不应对管理任何数字身份拥有最终控制权。</p><p>第二个要求是它必须有用和方便,例如，它必须作为所有在线活动的单点登录 Web 身份验证。</p></blockquote></li><li><p>易于使用和方便</p></li><li><p>安全</p><blockquote><p>公共的、无需许可的区块链代表了最复杂的可用数字安全，使用共识机制和密码学。</p></blockquote></li><li><p>隐私</p><blockquote><p>lifeID 的一个关键特性是，它将为用户提供通过<strong>利用经过验证的声明来确认其身份</strong>的能力，<strong>而不是向第三方提供个人详细信息</strong>以证明他们是他们所说的那个人。</p></blockquote></li><li><p>自治</p><blockquote><p>目前的身份状态下，由政府机构和公司定义和确定身份；在LifeID中，用户自己控制自己的身份，他们将在没有干预、不必要的监督下管理它。</p></blockquote></li><li><p>自主权身份和GDPR合规性</p><blockquote><p>GDPR 旨在通过将对身份数据的控制权交还给消费者来保护消费者。虽然 GDPR 适用于物理和数字身份管理，但它包括影响数字身份的条款，强调个人对其数据的控制。</p><p>GDPR包括以下身份权利：</p><ol><li>访问权——您的数据由什么组成、如何使用以及谁有权访问。</li><li>同意权——个人必须同意其数据的使用方式；他们也可以随时撤销同意。</li><li>被遗忘权——个人有权要求数据控制者删除该控制者持有的有关该个人的任何或所有数据。</li><li>便携权——个人有权在他们认为合适的时候获取、移动和提供对其数字数据的访问。</li><li>数据最小化——这是自我主权识别的关键。仅处理每个特定交易目的所需的个人数据。该义务适用于收集的个人数据量、处理范围、存储期限和可访问性。从本质上讲，只应授予所需的最少量个人数据。</li></ol></blockquote></li></ul><h2 id="The-lifeID-platform-and-ecosystem"><a href="#The-lifeID-platform-and-ecosystem" class="headerlink" title="The lifeID platform and ecosystem"></a>The lifeID platform and ecosystem</h2><h3 id="lifeID-Platform"><a href="#lifeID-Platform" class="headerlink" title="lifeID Platform"></a>lifeID Platform</h3><p>首先，lifeID平台是一个去中心化的基于区块链的平台（开源），充当一个开放的<strong>身份提供者</strong>。它是一个<strong>智能合约系统</strong>，也称为自执行协议。</p><h3 id="lifeID-SDK-amp-smartphone-App"><a href="#lifeID-SDK-amp-smartphone-App" class="headerlink" title="lifeID SDK &amp; smartphone App"></a>lifeID SDK &amp; smartphone App</h3><p>其次，lifeID 将提供一个软件开发工具包和智能手机App来播种和加速该平台的网络效应，此应用程序将提供自主身份界面、用户安全、密钥管理和凭证钱包。 lifeID 智能手机<strong>App将是开源</strong>的，任何人都可以开发自己的版本并根据自己的使用进行调整。 lifeID 智能手机应用程序旨在加速平台的使用，但不会有任何专有功能、访问权限或优先权。</p><p>除了智能手机应用程序，lifeID 还将提供开源软件开发工具包 (SDK)。 SDK 的目标是为生态系统合作伙伴提供他们需要的工具，以便<strong>为他们的应用程序集成 lifeID 平台层</strong>。开发人员可以使用 SDK 跨各种设备创建身份解决方案。例如，使用lifeID SDK 开发的浏览器扩展可以访问该平台并允许免密码登录网站。诸如智能手表之类的物联网设备可以验证身份并提供对建筑物的物理访问。</p><h3 id="lifeID-ecosystem"><a href="#lifeID-ecosystem" class="headerlink" title="lifeID ecosystem"></a>lifeID ecosystem</h3><p>第三，lifeID 正在与身份、区块链和多个垂直行业的生态系统合作伙伴合作，以确保 lifeID 平台成为事实上的自我主权身份的底层平台。</p><p>为了激发 lifeID 生态系统的网络效应，lifeID 将把旧的身份技术与基于区块链的身份解决方案联系起来。该连接有望充当桥梁，使 lifeID 能够更轻松地连接到其他基于区块链的功能。</p><h2 id="LifeID-platform-user-features"><a href="#LifeID-platform-user-features" class="headerlink" title="LifeID platform user features"></a>LifeID platform user features</h2><h3 id="Biometrically-secure-identity"><a href="#Biometrically-secure-identity" class="headerlink" title="Biometrically secure identity"></a>Biometrically secure identity</h3><p>任何人都可以使用 lifeID 平台创建个人数字标识符——该平台旨在用户终生使用。通过将 lifeID 平台与具有生物识别功能的智能手机和应用程序（如 lifeID 应用程序）相结合，用户将能够安全可靠地建立自己的身份，取代低效的在线密码和物理钥匙卡。</p><p>更安全的架构：</p><ol><li>目前PII数据集中存储，成为黑客容易获取的高价值目标。使用 lifeID，<strong>PII 数据在用户设备上保持加密状态</strong>。黑客需要攻击数十亿个单独目标，而不是攻击一个大目标。</li><li>最新一代的智能手机包含内置的基于硬件的生物特征识别，使其成为从物理世界到数字世界的理想桥梁。</li><li>iPhone等智能手机属于“围墙式安全花园”，恶意软件更难渗透和暴露用户隐私数据。</li><li>如果智能手机遭到破坏，基于 lifeID 的自主身份将<strong>允许用户撤销和更新用于证明其身份的安全密钥</strong>，使用不涉及智能手机的备份方式。</li></ol><h3 id="Individual-privacy"><a href="#Individual-privacy" class="headerlink" title="Individual privacy"></a>Individual privacy</h3><p>使用 lifeID，用户将对其个人身份信息的隐私保持 100% 的控制。<strong>身份信息不存储在服务器或“云”中，而仅以加密格式存储在用户的设备上</strong>。用户可以根据自己的隐私门槛选择如何备份这些信息。</p><p>lifeID 平台的设计使其在最坏的情况下只会公开一个随机生成的标识符，该标识符代表关于个人的“已验证声明”。（？？？）</p><p><strong>当第三方需要确认用户身份的某个方面时，只需向用户索取交易所需的特定属性的证明</strong>，而不需要收集和存储用户的所有隐私信息。该证明或“已核实的声明”将事先得到可信实体的确认，例如州机动车部门。该机制提供身份证明，例如年龄、家庭住址等，而不会暴露您的真实身份信息。这是一项基本的设计功能——第三方只能验证您身份的一个属性，他们无法访问身份本身。</p><p>此外，您的身份数据是分区的，因此一旦第三方完成身份验证交易，他们就<strong>不能将该信息重新用于其他未经授权的身份验证或商业目的</strong>。此外，他们无法使用 lifeID 来监控或检索有关您身份的其他信息。</p><h3 id="Seamless-identity-in-both-the-digital-and-physical-worlds"><a href="#Seamless-identity-in-both-the-digital-and-physical-worlds" class="headerlink" title="Seamless identity in both the digital and physical worlds"></a>Seamless identity in both the digital and physical worlds</h3><p>lifeID 平台上的用户身份将扩展到数字世界和物理世界。这意味着用户将能够通过相同的身份应用程序和界面使用手机  访问网站或建筑物。</p><h3 id="No-passwords"><a href="#No-passwords" class="headerlink" title="No passwords"></a>No passwords</h3><p>通过使用具有生物识别功能的应用程序，用户将能够登录到他们的账户，而不需要记住、写下或输入密码。</p><h3 id="Recover-and-backup"><a href="#Recover-and-backup" class="headerlink" title="Recover and backup"></a>Recover and backup</h3><p>lifeID 平台将提供多种密钥恢复选项，例如：</p><ol><li>自我备份</li><li>使用可信任的朋友或亲戚进行备份</li><li>使用可信组织进行备份</li></ol><h3 id="Verified-claims"><a href="#Verified-claims" class="headerlink" title="Verified claims"></a>Verified claims</h3><p>经验证的声明提供的额外好处是能够仅披露特定验证所需的信息。</p><p>使用 lifeID，<strong>经过验证的声明永远不会存储在公共区块链上</strong>，因为声明包含有关身份所有者的私人信息。声明仅由身份所有者和发出声明的实体持有。</p><p>如果发行人想要保留撤销声明的能力，他们可以添加撤销触发器。证明方可以出于各种原因触发撤销</p><h3 id="Identity-information-is-never-stored-on-the-lifeID-platform"><a href="#Identity-information-is-never-stored-on-the-lifeID-platform" class="headerlink" title="Identity information is never stored on the lifeID platform"></a>Identity information is never stored on the lifeID platform</h3><p>所有 PII，如姓名、出生日期、当前居住地址等，都不会存储在 lifeID 平台上。此信息经过加密，仅存储在安全设备（例如此人的手机）上。</p><p>链上存储的内容：</p><ul><li><p>去中心化标识符 (DID) </p><blockquote><p>DID 只是一个用于引用特定身份实例的唯一编号。它是查找特定身份描述符智能合约的关键。这类似于 DID 文档。</p></blockquote></li><li><p>DID文档</p></li><li><p>由撤销密钥签名的  可验证声明的Hash（可选）</p></li><li><p>lifeID遵循由声明持有者公开的W3C DID规范。</p></li></ul><h2 id="LifeID-platform-architecture"><a href="#LifeID-platform-architecture" class="headerlink" title="LifeID platform architecture"></a>LifeID platform architecture</h2><h3 id="How-lifeID-works：bridging-web-2-0-users-to-blockchain"><a href="#How-lifeID-works：bridging-web-2-0-users-to-blockchain" class="headerlink" title="How lifeID works：bridging web 2.0 users to blockchain"></a>How lifeID works：bridging web 2.0 users to blockchain</h3><p>lifeID平台由一组运行在区块链上的智能合约以及一些链下服务组成，这些服务将非基于区块链的应用程序与区块链生态系统连接起来。</p><p>用户将通过软件“网关”与lifeID平台进行交互，该网关将现有基础设施和协议连接到基于区块链的平台。对于大多数浏览互联网的用户来说，他们将通过身份提供者(如OpenID Connect)与lifeID平台进行交互。OpenID Connect是网络服务器在用户点击“登录Facebook、Google或Twitter”时使用的认证协议。对于其他应用程序，比如进入建筑物，你的lifeID手机应用程序直接与建筑物管理系统通信。该建筑的管理系统集成了lifeID平台，以确认身份持有人的有效性。</p><h3 id="Setting-up-and-using-entity"><a href="#Setting-up-and-using-entity" class="headerlink" title="Setting up and using entity"></a>Setting up and using entity</h3><p>lifeID 平台上身份的基本构建块称为实体或“信任锚”。 lifeID 平台上的实体可以代表人、组织或物理事物（例如门锁或智能设备）。这些实体&#x2F;信任锚使身份持有者能够管理用于证明控制权的加密密钥身份。 lifeID 平台上有专门定义的实体类型的一个原因是<strong>确保用户可以识别他们何时与物理世界中的另一个人、组织或设备进行交互</strong>。</p><ul><li><p>人类实体</p><blockquote><p>人类实体具有关联的智能合约，<strong>用户可以与之交互以管理代表其身份的加密密钥。</strong>与大多数其他可用的基于区块链的身份解决方案不同，<strong>用户的身份不是通过拥有 lifeID 平台中的某个加密私钥来定义的。相反，它由用户创建身份时设置的智能合约的状态表示。</strong></p><p><strong>人类实体是假名的，确保这个智能合约中的任何内容都不能用来识别任何特定的人。</strong>此外，用户将拥有多个人类实体，每个实体用于与另一个lifeID身份进行交互。这些都可以通过 lifeID 的电话应用程序（或任何其他 lifeID 平台兼容的应用程序）进行管理。</p></blockquote></li><li><p>组织实体</p><blockquote><p>组织实体可以包括公司、政府实体或非政府组织(NGO)</p><p>与人类实体一样，组织也将通过lifeID平台上的智能合约来代表。但是，组织的智能合约将以<u>允许一个或多个用户管理组织的加密密钥的方式</u>构建。组织实体还将支持添加诸如姓名、地址、电话号码或其他相关详细信息等公共信息的能力。</p></blockquote></li><li><p>IOT实体</p><blockquote><p>物联网实体是由人员或组织管理的物理设备。在lifeID平台上注册物联网设备身份将允许人们验证他们正在与正确的物联网实体进行交互</p></blockquote></li></ul><h4 id="lifeID-and-DID"><a href="#lifeID-and-DID" class="headerlink" title="lifeID and DID"></a>lifeID and DID</h4><p>去中心化标识符(DID)用于唯一地标识一个组织、人或事物，并且完全在身份所有者的控制之下。它们不依赖于集中的注册中心、身份提供者或证书颁发机构。在lifeID平台上，这些<strong>DID被链接到一个基于区块链的智能合约</strong>，该合约包含证明链接DID的所有权和控制权所需的所有配置、元数据和逻辑。</p><p>如果用户失去对 提供链接 DID 控制的加密私钥的访问时，则这种链接的智能合约使用户能够恢复对 DID 的使用。</p><h3 id="blockchain-implementation"><a href="#blockchain-implementation" class="headerlink" title="blockchain implementation"></a>blockchain implementation</h3><p>lifeID 平台旨在<strong>在任何支持智能合约的区块链上运行</strong>。它以这种方式设计，以减少实施平台的摩擦，目标是成为无处不在的标准身份协议。例如，以太坊或其他支持智能合约的区块链上的身份实例作为仅特定于该区块链的智能合约存在。</p><p>支撑 lifeID 平台的区块链必须满足以下要求：</p><ul><li><p>开发、无需许可的公共区块链</p></li><li><p>支持智能合约</p></li><li><p>分钟级确认</p><blockquote><p>对LifeID实体的更改必须在更新后一分钟内可供其他人使用。</p></blockquote></li><li><p>支持零知识证明</p></li><li><p>可扩展性</p><blockquote><p>lifeID平台必须建立在可以扩展到数十亿用户的区块链上。</p></blockquote></li></ul><h3 id="Buliding-on-the-lifeID-platform"><a href="#Buliding-on-the-lifeID-platform" class="headerlink" title="Buliding on the lifeID platform"></a>Buliding on the lifeID platform</h3><p>为了激发 lifeID 平台生态系统的网络效应，lifeID 将把旧的身份技术与基于区块链的身份解决方案联系起来。该连接将充当只读桥，以启用查找基于区块链的身份信息。</p><p>lifeID 平台的推出将包括其中几个桥接组件的开源参考实现，包括：</p><ul><li>OIDC 身份提供者</li><li>DID解析器</li></ul>]]></content>
    
    
    <categories>
      
      <category>DID</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Civic</title>
    <link href="/2023/05/30/Civic/"/>
    <url>/2023/05/30/Civic/</url>
    
    <content type="html"><![CDATA[<p>Civic Whitepaper</p><span id="more"></span><h3 id="Civic’s-existing-identity-products-and-services"><a href="#Civic’s-existing-identity-products-and-services" class="headerlink" title="Civic’s existing identity products and services"></a>Civic’s existing identity products and services</h3><p>目前，Civic 提供了一个名为 Civic Secure ldentity Platform（简称“SIP”）的数字身份平台，个人可以通过下载 Civic Secure Identity App（简称“Civic App”），在其设备上设置数字身份，并验证其身份来访问该平台，从而成为Civil用户。Civil App使用高级加密和生物识别锁（例如指纹 ID）将用户的 PII 安全地存储在用户的手机上。通过将此数据保留在用户控制中，Civic App 使黑客和其他恶意团体更难获得对用户信息的访问权限。</p><p>最初，用户根据要求将他们的 PII 捕获到 Civic App，然后由 Civic 进行彻底的验证过程。一旦完全验证，Civic将这些数据的证明写入区块链，然后数据的接收者可以使用区块链来验证PII的真实性和所有权。</p><p>Civic 的身份合作伙伴可以通过自定义 二维码请求用户的信息，用户可以使用 Civic App 进行扫描。一旦用户使用他或她的生物识别技术解锁 Civic App，用户就可以扫描这些二维码，准确查看请求的信息，并选择是否批准或拒绝请求。</p><p>因此，SlP 允许 根据请求者设置的要求，在用户和身份请求者之间进行自愿信息交换。这样，SlP 允许对由 Civic 或 Civic 身份合作伙伴验证的身份数据进行实时认证，并安全地共享该数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230530225105696.png" alt="image-20230530225105696"></p><h3 id="Civic‘s-planned-identity-ecosystem"><a href="#Civic‘s-planned-identity-ecosystem" class="headerlink" title="Civic‘s planned identity ecosystem"></a>Civic‘s planned identity ecosystem</h3><p>在其下一阶段的发展中，借助代币销售，Civic 打算超越其现有产品和服务，为 IDV 服务开发一个完全去中心化的 Civic 生态系统（“生态系统”）。该生态系统将由三个新组成部分组成：(1) 各种智能合约；(2) 称为 Civic 代币或“cVc”的本土实用代币；以及 (3) 由 Civic 和其他公司推出的新软件应用程序，允许参与者在生态系统内进行交互。</p><p>用户将使用 Civic 应用程序将其数据存储在个人设备上，并可选择备份到基于云或分布式存储平台上的个人帐户。</p><h4 id="the-mechanics-of-attestation"><a href="#the-mechanics-of-attestation" class="headerlink" title="the mechanics of attestation"></a>the mechanics of attestation</h4><p>存储在用户设备上的Pll可以由验证器来验证。用户可以与生态系统中信任给定验证器的任何其他参与者共享Pll和任何证明。</p><p>用户的Pll以层次结构构成，包含类似于SSN、地址、城市、国家和出生日期的元素。这些数据遵循一个已定义的模型，Civic的目的是遵循现有的行业标准，甚至为行业的进一步标准化做出贡献。</p><p>证明的可证明性是通过将数据组织到Merkle树来实现的，其中每个节点代表Pll的一个元素(例如，姓名)，每个节点包含其内容的哈希值及其子节点的哈希值(例如，姓和名)。这将产生一个“根哈希”(也称为默克尔根)，可以用作被证明数据的指纹。此根哈希记录在区块链中，并由验证者签名，对特定 Pll 进行证明。被称为“随机数”的任意数字被用于随机化结构化数据上的哈希值，这些数据具有相对较小的可能值范围，将任何哈希值被反转的风险降至最低。如果用户不希望显示所有被证明的底层Pll，则可以选择性地显示Merkle树的部分，并为用户不希望显示的任何元素提供哈希值。</p><blockquote><p>这种结构有两个优点：（1）它通过允许用户在不同情况下有选择地透露个人信息来增强用户控制； (2) 通过使用区块链的属性来证明数据在做出证明后没有被篡改，从而提高安全性。</p></blockquote><p>参与者复制哈希的唯一方法是从原始数据创建它。这允许用户与生态系统中的另一个参与者共享数据，并证明它与验证器之前证明的数据相同。如果验证者因任何原因撤销其认证，则可以在相关的区块链交易中反映出来，但认证的细节永远无法更改。记录这些交易的区块链目前是比特币区块链，因为它的完整性和广泛采用，但同样的设计也可以在任何其他区块链平台上使用。</p><p>用于记录这些证明的方法是创建派生地址，这需要花费少量加密货币。使用椭圆曲线密码ECC的加法属性可以将root hash转化为一个有效的区块链地址：$k_{priv}+h&#x3D;k_{attest}$，其设计方式使得无法确定与地址相关联的用户和验证者。这对于保护参与者的隐私至关重要。</p><h3 id="Ecosystem-token-CVC"><a href="#Ecosystem-token-CVC" class="headerlink" title="Ecosystem token(CVC)"></a>Ecosystem token(CVC)</h3><p>Civic 拟引入一种 Civic 代币，即 CVC，作为参与者之间在生态系统内进行身份相关交易的一种结算形式。交易中支付的 CvC 将作为共享信息的奖励分发给 Validator 和 User。他们分享CVC的比例由智能合约定义，可以通过生态系统参与者的共识进行调整。</p><p>拥有 CVC 的 Civic 用户可以使用他们的 CVC 直接从 Civic 购买现有服务。Civic 还可以构建额外的以身份为中心的服务，这些服务可以交换代币，包括：</p><ul><li>进行个人背景调查的服务；</li><li>区块链公证服务，可以证明身份和文件的真实性；</li><li>暗网监控和搜索；</li><li>访问个人信用报告；</li><li>点对点身份服务。</li></ul><h3 id="A-market-for-efficient-attestation-of-User-data"><a href="#A-market-for-efficient-attestation-of-User-data" class="headerlink" title="A market for efficient attestation of User data"></a>A market for efficient attestation of User data</h3><ol><li>用户向服务提供商A申请产品或服务，并从civic App向他们发送所需的Pll。</li><li>服务提供商A使用其现有的验证方法验证用户的PII。</li><li>通过参考存储在用户设备上的 PII，服务提供商A计算该 PII 的哈希值并在区块链上记录对该 PII 的证明。证明还可能包括支持元数据，例如其验证级别、与服务提供商 A 的验证过程相关的详细信息或任何适用的行业标准（例如 NIST、FIPS 或 PIV 标准）。然后将此证明的区块链交易详细信息提供给用户.</li><li>稍后，用户向服务提供商 B 申请产品或服务。</li><li>服务提供商 B 请求访问用户 PII 的全部或某些部分，包括围绕服务提供商 B 愿意接受的数据的规则和要求。Civic 应用程序随后将确定是否满足这些要求。</li><li>假设用户已经并且愿意共享所请求的数据，服务提供商B和用户同意一个双方都可以接受的验证器，该验证器先前已经对数据以及围绕该数据的规则和要求进行了验证。在这种情况下，我们将假定可相互接受的验证者是服务提供者A，它为其认证提供价格(以cvC表示)，并且服务提供者B接受该价格</li><li>然后，用户向服务提供商 B 发送服务提供商 A 证明中数据类型的概述，以及使服务提供商 B 能够找到和查看与服务提供商A相关的区块链交易详细信息的必要信息，作为区块链上的证明。然后，服务提供商 B 将能够为该 PII重新创建哈希，并将它们与区块链上的交易进行比较，从而确认所请求数据的可用性。如果服务提供商B对产生的哈希值感到满意，那么服务提供商B可以购买证明，并支付与该证明价格相对应的cvC金额(通过智能合约)到托管。</li><li>一旦服务提供商 B 将 cvC 支付到托管中，用户就可以通过他&#x2F;她的 Civic App，向服务提供商 B 发送带有请求内容的纯文本 Pll。</li><li>为完成交易，用户触发 cvC 从托管中释放，该 cvC 按智能合约定义的比例在用户和服务提供商 A（原始验证器）之间共享。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230531111949476.png" alt="image-20230531111949476"></p>]]></content>
    
    
    <categories>
      
      <category>DID</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EverID</title>
    <link href="/2023/05/28/DID-EverID/"/>
    <url>/2023/05/28/DID-EverID/</url>
    
    <content type="html"><![CDATA[<h2 id="EverID-WhitePaper"><a href="#EverID-WhitePaper" class="headerlink" title="EverID-WhitePaper"></a>EverID-WhitePaper</h2><hr><p>EverID 建立了一个去中心化的数字身份系统来<strong>存储和确认用户身份数据、文档和生物特征</strong>。该平台可供从出生到死亡的所有人使用。它<strong>不需要移动设备加入</strong>，经过加密以保护用户隐私，并可与其他系统互操作。</p><span id="more"></span><p>EverID 使用户验证快速且具有成本效益：每次验证仅需几美分，每月可处理 1-100 亿笔交易——并能够扩展至数万亿。与当前的集中式或公共分布式数据库相比，该平台的去中心化架构还提供了完整的个人数据所有权和更高级别的安全性。</p><h3 id="Blockchain-Technology"><a href="#Blockchain-Technology" class="headerlink" title="Blockchain Technology"></a>Blockchain Technology</h3><h4 id="a-Technological-Principles"><a href="#a-Technological-Principles" class="headerlink" title="a. Technological Principles"></a>a. Technological Principles</h4><p>EverID 基础设施在网络中的一系列<code>超级节点</code>上运行，这些超级节点是区块链的宿主。他们还托管每个用户的 IPFS 存储位置、用于集成其他系统和数据的<code>管道系统</code>、允许个人将其数据传输到 EverID 应用程序的<code>桥接服务</code>以及用于启用来自支持 SDK 的设备的交易的<code> API 服务器</code>。</p><p>超级节点上的数据通过用户的<u>公钥&#x2F;私钥对、生物特征以及密码&#x2F;PIN</u> 进行保护。<code>EverID DApp</code> 和 <code>EverID Agent DApp </code>都是基于以太坊区块链的加密货币钱包。，EverID 系统中的 DApp 也使用用户的生物特征和密码&#x2F;PIN 进行保护，<code>Bridge Service </code>也是如此。</p><p>EverID API 和 Ever SDK通过一个 per-partner API密钥和per-partner SDK实现密钥保护。SDK要求在公共访问设备（Public Access Device，PAD）的软件中嵌入SDK实现密钥，但是可以刷新API密钥，从而防止密钥劫持危害系统。在密钥劫持的情况下，一个新的 API 密钥被发布给合作伙伴组织，并通过 SDK 在未受损的设备上更新。</p><p>用户身份信息的存储数组称为EverID数据报。它由一系列嵌套的信息组成，这些信息被锁在生物识别锁和知识锁(密码、PIN)后面，这些锁旨在引导解锁数据报的下一部分。每个人都有一个EverID数据报，存储在超级节点的IPFS中，由智能合约引用，智能合约将他们的身份记录到EverID ID区块链中。</p><p>通过API和SDK，EverID系统可以集成到EverID产品未涉及的其他应用程序和其他设备中。</p><p>通过管道系统，不同的信息源可以集成到用户空间中，允许个人将现有系统的数据合并到他们的EverID中。</p><h4 id="b-EverID-Technology-Stack"><a href="#b-EverID-Technology-Stack" class="headerlink" title="b. EverID Technology Stack"></a>b. EverID Technology Stack</h4><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230529170856478.png" alt="image-20230529170856478"></p><h4 id="c-Architecture-Diagram"><a href="#c-Architecture-Diagram" class="headerlink" title="c. Architecture Diagram"></a>c. Architecture Diagram</h4><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230529171602267.png" alt="image-20230529171602267"></p><p>(看不明白啊)</p><h4 id="d-Biometrics"><a href="#d-Biometrics" class="headerlink" title="d. Biometrics"></a>d. Biometrics</h4><p>EverID使用生物识别技术，或个人特定的独特身体或行为特征来识别用户。<strong>目前，EverID利用面部和指纹扫描</strong>，这两种方法都达到了非常高的准确性。通过包括两种生物识别来源，EverID实现了比市场上大多数产品更高的安全性。随着生物识别技术的进步，EverID将整合其他生物识别来源，包括虹膜、脉搏、声音和DNA。</p><p>通过将生物特征记录到EverID中，系统能够识别特定的个人，并<strong>确保每个用户都有且只有一个EverID记录，防止Sybil攻击。</strong></p><h4 id="e-EverID-Datagram"><a href="#e-EverID-Datagram" class="headerlink" title="e. EverID Datagram"></a>e. EverID Datagram</h4><p><strong>EverID数据报是用户身份信息的专有存储文件</strong>。EverID数据报驻留在用户的移动设备和EverID超级节点中。一旦设备上线，对数据报的任何更新都会与该个人的数据报在他们的设备上或在 EverID 超级节点中的其他副本进行镜像&#x2F;同步。</p><p>EverID DApp、Agent DApp 或支持 EverID 的设备可以创建 EverID 数据报。但是，从外部访问 EverID 数据报只能通过 EverID API 。</p><p>EverID 数据报及其存储始终由用户控制，允许他们决定谁可以访问哪些信息，以及这些信息如何长期存储。如果用户希望删除他们的 EverID，注册期间使用的匿名生物识别标识符会保留。这可以防止用户尝试在系统中创建不同的身份。</p><h4 id="f-EverID-DApps"><a href="#f-EverID-DApps" class="headerlink" title="f. EverID DApps"></a>f. EverID DApps</h4><p>EverID DApp 和 EverID Agent DApp 都基于通常用于为以太坊区块链创建加密货币钱包的代码。</p><p>拥有自己技术的用户将使用 EverID DApp 自行注册、存储和直接控制他们的 EverID。 EverID 数据报将存储在本地，在 EverID 超级节点 IPFS 存储阵列中有一个备份副本。</p><p>对于那些不拥有自己技术的个人，他们可以通过拥有运行<code>EverID Agent DApp</code>的设备的代理注册到 EverID。用户输入所有相同的信息，就好像他们在 EverID DApp 上自行注册一样，但是，他们在代理的帮助下帮助他们进行扫描和数据输入。</p><h4 id="g-EverID-Application-Programming-Interface-API"><a href="#g-EverID-Application-Programming-Interface-API" class="headerlink" title="g. EverID Application Programming Interface(API)"></a>g. EverID Application Programming Interface(API)</h4><p>通过EverID API和SDK, EverID系统可以与其他应用程序和设备集成，而不是由EverID的产品直接解决。</p><p>EverID客户端API是用于构建客户端应用程序的RESTful接口。</p><p>EverID API和SDK由a per-implementation API key and per-partner SDK key保护。这两种类型的密钥有层次结构，<strong>SDK密钥有API密钥</strong>。SDK要求将<code>SDK实现密钥</code>嵌入在PAD (Public Access Device)或软件应用的软件中。可以刷新<code>API密钥</code>，从而防止密钥劫持危及系统。</p><p><strong>通过 API，用户可以在他们不拥有的设备上与他们的 EverID 进行交互</strong>，例如支持指纹传感器的 ATM 或支持面部识别的医疗平板电脑。他们还能够在 EverID 未提供的应用程序中使用他们的 EverID 来提供生物识别解锁、简单的用户入职（自动 KYC&#x2F;AML 检查）和医疗表格自动填写等服务。</p><h4 id="h-EverID-Core-Smart-contracts"><a href="#h-EverID-Core-Smart-contracts" class="headerlink" title="h. EverID Core Smart-contracts"></a>h. EverID Core Smart-contracts</h4><p>EverID 使用以太坊区块链的 Solidity 智能合约框架，建立在五个主要核心智能合约之上：</p><ul><li><p>EverID 创建和管理</p><blockquote><p>用于在平台上创建和发展EverID的智能合约，该智能合约需要用户的公钥、用户的 EverID 数据报、用户的用户名、用户的密码和用户的 PIN。该智能合约被写入 EverID ID 区块链，智能合约包括指向存储用户 EverID 数据报的 IPFS 存储阵列 URI 的指针、用于完整性检查的 EverID 数据报的哈希值，以及作为共享秘密的创建时间。</p></blockquote></li><li><p>EverID 验证</p><blockquote><p>用于验证 EverID 的智能合约。验证请求可以来自 EverID DApp、EverID Agent DApp 或支持 EverID API 的应用程序或设备。验证请求被写入 EverID 交易区块链，需要用户的公钥、生物识别样本、用户的用户名和用户的 PIN。</p></blockquote></li><li><p>EverID 交易</p><blockquote><p>用于跟踪身份信息共享和针对用户的EverID进行的交易的智能合约。例如，来自用户 EverID 的共享医疗信息的交易请求会记录用户将特定信息授予与用户诊所相关的个人的另一个公钥地址。交易请求被写入 EverID 交易区块链并需要用户的公钥、生物识别样本、用户的 PIN 和用户的用户名。共享的信息、信息的接收者（通过他们的公钥）、可用性的长度以及可用性的实施都被记录下来。</p></blockquote></li><li><p>EverID 远程管理</p><blockquote><p>不拥有自己的技术，使用Agent终端管理和更新其EverID数据报的个人使用的智能合约。远程管理请求被写入 EverID ID 区块链，需要用户的公钥、两个不同的生物识别样本、用户的 PIN、用户的用户名和用户的密码。</p></blockquote></li><li><p>组织EverID</p><blockquote><p>组织 EverID 是使用至少两个 EverID 输入的组织 EverID 智能合约模板创建的。该组织 EverID 智能合约能够创建一个组织 EverID，它能够像任何其他 EverID 一样参与 EverID 系统。</p></blockquote></li></ul><h4 id="i-Ethereum-Private-Blockchain"><a href="#i-Ethereum-Private-Blockchain" class="headerlink" title="i. Ethereum Private Blockchain"></a>i. Ethereum Private Blockchain</h4><p>EverID 去中心化身份平台和相关交易记录都被捕获并存储在<strong>以太坊区块链的一组私有实例</strong>中。</p><h4 id="j-EverID-Supernodes"><a href="#j-EverID-Supernodes" class="headerlink" title="j. EverID Supernodes"></a>j. EverID Supernodes</h4><p>Identity Network 平台是去中心化的，这意味着它是一个分布式系统，依赖于某些集中式服务进行协调和引导。 EverID 基础设施在互联网网络中的一系列超级节点上运行。<strong>这些超级节点是用于协调身份网络平台的集中服务的主机。</strong>这些集中式服务包括：私有以太坊区块链、用于每个用户存储的 IPFS 存储阵列、允许个人将数据从区块链传输到 EverID DApp 实例的桥接服务、用于集成其他系统和数据的管道系统以及 API 服务器启用来自支持 API 和 SDK 的设备的交易。</p><p>EverID Filer 服务负责在系统中创建 EverID，并在个人用户名、公钥和 PIN 之间创建映射。</p><h4 id="k-Portals"><a href="#k-Portals" class="headerlink" title="k. Portals"></a>k. Portals</h4><p>为了能够控制 EverID 平台并允许访问特定服务，EverID 超级节点将运行三个门户：<strong>API 管理门户、个人管理门户和代理管理门户</strong>。API 管理门户使 EverID 能够向参与组织颁发 SDK 许可证密钥和 API 许可证密钥。它还支持共享开发资源以将 EverID 实施到软件应用程序或嵌入式设备中。个人管理门户使 EverID 用户能够访问 Bridge 系统以在发生灾难或事故时恢复他们的 EverID。代理管理门户使 EverID 能够发布代理密钥(类似于API许可密钥)，该密钥属于组织的主代理密钥下的层次结构。</p><h4 id="i-Bridge-System"><a href="#i-Bridge-System" class="headerlink" title="i. Bridge System"></a>i. Bridge System</h4><p>桥接系统是一个特殊的认证系统，通过一系列的挑战和生物识别检查，确保个人是他们的EverID的所有者，应该被允许<strong>访问他们的EverID保存到一个新的EverID DApp实例</strong>。这在概念上类似于“从备份恢复”服务。</p><h4 id="m-Conduit-System"><a href="#m-Conduit-System" class="headerlink" title="m. Conduit System"></a>m. Conduit System</h4><p>通过管道系统，不同来源的信息可以整合到EverID平台的用户空间中:允许个人将现有系统的数据整合到他们的个人EverID中。</p>]]></content>
    
    
    <categories>
      
      <category>DID</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ID3算法原理</title>
    <link href="/2023/05/15/ID3%E7%AE%97%E6%B3%95/"/>
    <url>/2023/05/15/ID3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>ID3算法是一种贪心算法，用来构造决策树。ID3算法起源于概念学习系统（CLS），以信息熵的下降速度为选取测试属性的标准，即在每个节点选取还尚未被用来划分的具有最高信息增益的属性作为划分标准，然后继续这个过程，直到生成的决策树能完美分类训练样例。</p><span id="more"></span><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><h3 id="1-算法概述"><a href="#1-算法概述" class="headerlink" title="1. 算法概述"></a>1. 算法概述</h3><p>ID3算法是一种<strong>分类预测</strong>算法，算法的<strong>核心是“信息熵”</strong>。ID3算法通过计算每个属性的信息增益，认为信息增益高的是好属性，每次划分选取信息增益最高的属性为划分标准，重复这个过程，直至生成一个能完美分类训练样例的决策树。</p><p>决策树是对数据进行分类，以此达到预测的目的。该决策树方法先根据训练集数据形成决策树，如果该树不能对所有对象给出正确的分类，那么选择一些例外加入到训练集数据中，重复该过程一直到形成正确的决策集。决策树代表着决策集的树形结构。</p><h3 id="2-决策树"><a href="#2-决策树" class="headerlink" title="2. 决策树"></a>2. 决策树</h3><p>决策树(decision tree)是一类常见的机器学习方法。例如，我们要 对 “这是好瓜吗?”这样的问题进行决策时，通常会进行一系列的判断或“子决策”：我们先看“它是什么颜色?”，如果是 “青绿色”，则我 们再看“它的根蒂是什么形态?”，如果是“蜷缩 ”，我们再判断“它敲起来是什么声音?”，最后，我们得出最终决策：这是个好瓜。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515160908712.png" alt="image-20230515160908712"></p><p>决策过程中提出的每个判定问题都是对某个属性的“测试 ”，每个测试的结果或是导出最终结论，或是导出进一步的判定问题，其考虑范围是在上次决策结果的限定范围之内。决策树学习的目的是为 了产生一棵泛化能力强，即处理未见示例能力强的决策树。</p><h3 id="3-信息熵和信息增益"><a href="#3-信息熵和信息增益" class="headerlink" title="3. 信息熵和信息增益"></a>3. 信息熵和信息增益</h3><p>&#x3D;&#x3D;目标：选择最佳分类策略后，整体的信息熵变得最小。&#x3D;&#x3D;</p><p>决策树的关键是如何选择最优划分属性，一般而言，随着划分过程不断进行，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的“纯度”(purity)越来越高。</p><p>经典的 “不纯度”的指标有三种，分别是<strong>信息增益</strong>（ID3 算法）、<strong>信息增益率</strong>（C4.5 算法）以及<strong>基尼指数</strong>（Cart 算法）</p><h4 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h4><p>信息熵是衡量样本集合纯度常用的一种指标，假设当前样本集合D中第$k$类样本所占的比例为$p_k(k&#x3D;1,2,…,|y|)$，则D的信息熵定义为<br>$$<br>Entry(D)&#x3D;-\sum_{k&#x3D;1}^{|y|}p_klog_2\ p_k<br>$$<br><strong>Ent(D)的值越小，则D的纯度越高</strong>；即信息熵越大，不确定性越大。</p><h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p>假设离散属性$a$有$V$个可能的取值${a^1,a^2,…,a^V}$，则如果使用属性$a$来对样本集合D进行分类，会产生$V$个不同的分支，其中第$v$个分支结点包含了D中所有在属性$a$上取值为$a^v$的样本，记为$D^v$，可以根据信息熵的定义计算$D^v$的信息熵，再考虑不同的分支结点包含的样本数不同，给分支结点赋予权重$|D^v|&#x2F;|D|$，于是可以计算<strong>使用属性$a$对样本集进行划分所获得的信息增益</strong>：<br>$$<br>Gain(D,a)&#x3D;Ent(D)-\sum_{v&#x3D;1}^V \frac{|D^v|}{|D|}Ent(D^v)<br>$$<br>一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的“纯度提升”越大。因此，我们可用信息增益来进行决策树的划分属性选择。</p><h3 id="4-ID3算法流程及实例"><a href="#4-ID3算法流程及实例" class="headerlink" title="4. ID3算法流程及实例"></a>4. ID3算法流程及实例</h3><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>核心思想：在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。</p><p>具体方法：从根结点（root node）开始，对结点计算所有可能的特征信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点；再对子结点递归地调用以上方法，构建决策树；直到所有特征的信息增益均很小或没有特征可以选择。最后得到一个决策树。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>数据集：</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515171543944.png" alt="image-20230515171543944"></p><p>该数据集包含17个训练样例，用以学习一棵能预测没剖开的是不是好瓜的决策树。 在决策树学习开始时，根结点包含D中的所有样例，其中正例占$p_1&#x3D;\frac{8}{17}$，反例占$p_2&#x3D;\frac{9}{17}$，于是，根据定义可计算出根结点的信息熵为<br>$$<br>Ent(D)&#x3D;-\sum_{k&#x3D;1}^2p_k \ log_2\ p_k&#x3D;-(\frac{8}{17}log_2\frac{8}{17}+\frac{9}{17}log_2\frac{9}{17})&#x3D;0.998<br>$$<br>下面计算当前属性集合{色泽，根蒂，敲声，纹理，脐部，触感}中每个属性的信息增益。</p><p>以属性”色泽”为例，它有三个可能的取值{青绿，乌黑，浅白}，如果使用该属性对D进行划分，则可以得到三个子集，记为$D^1$（色泽&#x3D;青绿），$D^2$(色泽&#x3D;乌黑)，$D^3$（色泽&#x3D;浅白）</p><p>子集$D^1$包含的样本共6个，编号为{1,4,6,10,13,17}，其中正例占$p_1&#x3D;\frac{3}{6}$，反例占$p_2&#x3D;\frac{3}{6}$；子集$D^2$包含的样本共6个，编号为{2,3,7,8,9,15}，其中正例占$p_1&#x3D;\frac{4}{6}$，反例占$p_2&#x3D;\frac{2}{6}$；子集$D^3$包含的样本共5个，编号为{5,11,12,14,16}，其中正例占$p_1&#x3D;\frac{1}{5}$，反例占$p_2&#x3D;\frac{4}{5}$；计算出用“色泽”划分之后所获得的 3 个分支结点的信息熵为</p><p>$$<br>Ent(D^1)&#x3D;-(\frac{3}{6}log_2\frac{3}{6}+\frac{3}{6}log_2\frac{3}{6})&#x3D;1.000,<br>$$</p><p>$$<br>Ent(D^2)&#x3D;-(\frac{4}{6}log_2\frac{4}{6}+\frac{2}{6}log_2\frac{2}{6})&#x3D;0.918,<br>$$</p><p>$$<br>Ent(D^3)&#x3D;-(\frac{1}{5}log_2\frac{1}{5}+\frac{4}{5}log_2\frac{4}{5})&#x3D;0.722<br>$$</p><p>因此，计算出属性色泽的信息增益为：<br>$$<br>Gain(D,色泽)&#x3D;Ent(D)-\sum_{v&#x3D;1}^3\frac{|D^v|}{|D|}Ent(D^v)<br>$$</p><p>$$<br>&#x3D;0.998- (\frac{6}{17}×1.000+\frac{6}{17}×0.918+\frac{5}{17}×0.722）&#x3D;0.109<br>$$<br>类似的，计算其他属性的信息增益：</p><p>$$ Gain（D,根蒂）&#x3D; 0.143; Gain（D , 敲声）&#x3D; 0.141;  $$$$ \<br>Gain（D ,纹理）&#x3D; 0.381; Gain（D , 脐部）&#x3D; 0.289;$$ $$  \<br>Gain（D ,触感）&#x3D; 0.006.$$</p><p>属性 “纹理”的信息增益最大，于是它被选为划分属性。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515173747632.png" alt="image-20230515173747632"></p><p>然后，决策树学习算法将对每个分支结点做进一步划分。</p><h3 id="5-ID3算法缺点"><a href="#5-ID3算法缺点" class="headerlink" title="5. ID3算法缺点"></a>5. ID3算法缺点</h3><ul><li>ID3没有剪枝策略，容易过拟合</li><li>信息增益准则对可取值数目较多的特征有所偏好。因为相同条件下，取值比较多的特征的信息增益大于取值较少的特征</li><li>只能用于处理离散分布的特征，没有考虑到特征连续值的情况，即如人的身高、体重都是连续值，无法在ID3算法中应用，即ID3算法更适合做分类</li><li>没有考虑缺失值</li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo+github+typora 图床</title>
    <link href="/2023/05/15/PicGo-github-%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/05/15/PicGo-github-%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p>在日常使用typora过程中，插入图片会将图片保存在本地，图片地址不对（是本地地止），<strong>直接复制到网站上，会导致图片加截不出来</strong>。因此将博客上传到github时，要么需要将图片同md文件同时上传到github，要么需要将图像上传到其他的一些图床上，再将md文件中的图像链接替换成网络地址。之前一直想搞这个事情，但是平时的文章中图片不是很多，<del>就懒得弄（懒死bushi）</del>。</p><p>不过还是想解决掉这个问题，避免以后在上传blog之前还得将图片上传到图床上，因此想利用PicGo搭配typora将图片自动上传到第三方图床上，由于github免费，所以选择它作为第三方图床。</p><ul><li>Typora：文章编辑器</li><li>PicGo：自动上传typora中的图片</li><li>Github：作为第三方图床，存储图片</li><li>CDN：Github在国内访问并不稳定，加速访问</li></ul><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><a href="https://typora.io/">Typora</a>：目前typora已经开始收费了，可以尝试使用历史版本</p><p><a href="https://molunerfinn.com/PicGo/">PicGo</a></p><h2 id="Github-配置"><a href="#Github-配置" class="headerlink" title="Github 配置"></a>Github 配置</h2><ol><li><p>在自己的github中新建一个仓库，用来存储上传的图片 eg：Yank3l&#x2F;ImageHosting</p></li><li><p>点击右上角头像-&gt;Setting-&gt;Developer settings-&gt;Personal access tokens-&gt;tokens(classic)-&gt;生成token</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515105059306.png" alt="image-20230515105059306"></p></li></ol><h2 id="PicGo配置"><a href="#PicGo配置" class="headerlink" title="PicGo配置"></a>PicGo配置</h2><p>我是用的是2.4.0-beta.1版本</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515105335763.png" alt="image-20230515105335763"></p><ul><li>图床配置名：以前的版本好像是没有这个选项的，这里我就随便起了个名字</li><li>设定仓库名：填写自己的github用户名&#x2F;仓库名 例如我的github用户名为yank3l，仓库名为ImageHosting</li><li>设定分支名：填写main，有的教程写的是master，会出现问题，这是因为github创建的仓库默认都是main分支，不是master分支</li><li>设定token：复制github生成的token数据</li><li>设定存储路径：是指在仓库名下会生成一个文件夹，在该文件夹中存储图像</li><li>设定自定义域名：<code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code></li></ul><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><p>在上传图片中可能会出现网络错误，这里设置代理，方便在上传图片时也使用主机的代理，我是用的是<code>clash</code>，其默认是端口号是7890，因此代理地址设置为<code>http://127.0.0.1；7890</code>（PicGo<strong>只支持简单HTTP代理</strong>），插件安装镜像按照官方文档设置为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://registry.npm.taobao.org/<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515111306729.png" alt="image-20230515111306729"></p><h2 id="typora测试"><a href="#typora测试" class="headerlink" title="typora测试"></a>typora测试</h2><p>typora上传服务可以选择app或者命令行，这里选择的是app，完成后点击验证图片上传选项，会显示上传成功，仓库里会上传typora的图标。</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515111504157.png" alt="image-20230515111504157"></p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515112256013.png" alt="image-20230515112256013"></p><p>配置过程中可能会出错，可以在PicGo的日志文件中查看错误原因和代码，一般来说错误代码为4xx的一般是配置填写错误。其他原因查看文档以及github的issue</p><p><img src="https://cdn.jsdelivr.net/gh/Yank3l/ImageHosting/Yank3l-PIC/image-20230515112322848.png" alt="image-20230515112322848"></p><p>参考链接</p><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here">PicGo指南</a></p><p><a href="https://github.com/Molunerfinn/PicGo/issues">PicGo-issue</a></p><p><a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md">PicGo常见问题</a></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
      <tag>github</tag>
      
      <tag>PicGo</tag>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OAuth2.0</title>
    <link href="/2022/07/15/OAuth2-0/"/>
    <url>/2022/07/15/OAuth2-0/</url>
    
    <content type="html"><![CDATA[<h1 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h1><p>OAuth（Open Authorization，开放授权）是一个开放标准的授权协议，允许用户授权第三方应用访问他们存储在资源服务上受保护的信息，而不需要将用户名和密码提供给第三方应用。</p><span id="more"></span><table><tr><td bgcolor=#EAEAEF>文章内容来自阿里云相关介绍，相关链接见文章末尾。</td></tr></table><hr><ul><li><p>OAuth2是用于REST&#x2F;APIs的代理授权框架(delegated authorization framework)</p></li><li><p>OAuth2是基于令牌Token的授权,在无需暴露用户密码的情况下,让应用获取对用户数据有限访问权限</p></li><li><p>OAuth2解耦认证和授权</p></li></ul><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>让朋友去自己家取东西，如果我直接给他门禁系统的密码，朋友就拥有了与我同样的权限，这样不太合适。如果我想取消朋友进入我家的权限，需要更改密码才可以，操作麻烦。</p><p>能不能有种方法，朋友可以进入我家，但是又不知道我家门禁的密码。朋友如果多次进入我家，每次都需要经过我的授权，我不授权的就进不去，我授权后才能进去。</p><p>方案如下：</p><p>第一步，在门禁系统的密码输入器下面，增加一个按钮，比如叫做”获取授权”。朋友需要首先按这个按钮，去申请授权。</p><p>第二步，朋友按下按钮以后，我的手机就会弹出提示：有人正在请求授权，并显示朋友的姓名。我确认情况属实，点击同意授权。</p><p>第三步，门禁系统得到我的确认后，向朋友发送一个进入房屋的令牌（access token），令牌是类似密码的一串数字，只在短期内有效。</p><p>第四步，朋友向门禁系统输入令牌，进入房屋。</p><h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><ul><li><strong>Third-party application</strong>: 第三方应用，又称”客户端”（client），如上面场景中的门禁系统。</li><li><strong>Resource Owner</strong>: 资源拥有者，也就是用户。</li><li><strong>Http Service</strong>: 服务提供商，也就是持有Resource Server的存在方。可以理解为类似微信，钉钉这样具备用户信息的服务者。</li><li><strong>Authorization server</strong>: 认证服务器，即服务提供商专门用来处理认证的服务器。</li><li><strong>Resource server</strong>: 资源服务器，即服务提供商存放用户生成的资源的服务器。与认证服务器是不同的逻辑节点，但是在物理上，双方是可以在一起的</li><li><strong>User Agent</strong>: 用户代理，一般就是指的浏览器。</li><li><strong>客户端凭证</strong>: Client Id和密码用于认证用户。</li><li><strong>访问令牌</strong>: 授权服务提供者在接收到用户请求后,颁发的访问令牌。</li><li><strong>刷新令牌</strong>(Refresh Token): 用于<strong>获取一个新的令牌</strong>。由于令牌的有效期比较短，一旦失效，用户需要再获取令牌的流程是比较繁琐的。为了提升用户体验，可以使用reflesh_token来获取新的令牌。</li></ul><p><strong>举例</strong></p><p>【小明】授权【在线打印app】到【QQ空间】访问【小明的指定相册】，以完成打印工作。</p><p><img src="https://s1.ax1x.com/2023/05/14/p9cHec4.png"></p><h2 id="OAuth应用场景"><a href="#OAuth应用场景" class="headerlink" title="OAuth应用场景"></a>OAuth应用场景</h2><p><strong>开放系统间授权：社交联合登录、开放API平台</strong></p><p>比如：APP或者网页接入一些第三方应用时，时常会需要用户登录另一个合作平台，比如钉钉，QQ，微博的授权登录, 这些平台都提供了基于OAuth2的机制，你可以用这些平台的账号登录而无需在其他网站上进行注册，并授权此网站获取其账号信息，包括用户名、头像等。</p><p><strong>现代微服务安全：单页浏览器App(HTML5&#x2F;JS&#x2F;无状态)、无线原生App</strong></p><p>比如：app登录请求后台接口，为了安全认证，所有请求都带token信息，如果登录验证、请求后台数据。</p><p><strong>企业内部应用认证授权(IAM&#x2F;SSO)，前后端分离单页面应用（spa）</strong></p><p>比如：有个应用是别人开发的，你需要将系统进行整合或者数据对接，此时需要单点登录；前后端分离框架，前端请求后台数据，需要进行oauth2安全认证。</p><h2 id="token-vs-password"><a href="#token-vs-password" class="headerlink" title="token vs password"></a>token vs password</h2><p>（1）<strong>令牌是短期的</strong>，到期会自动失效，用户自己无法修改。<strong>密码一般长期有效</strong>，用户不修改，就不会发生变化。</p><p>（2）<strong>令牌可以被资源持有者撤销，会立即失效</strong>。以上例而言，我可以随时取消朋友的令牌，密码一般不允许被他人撤销。</p><p>（3）<strong>令牌有权限范围</strong>（scope），比如使用令牌只允许进入客厅，不允许进入卧室。对于网络服务来说，只读令牌比读写令牌更安全，而<strong>密码一般是完整权限</strong>。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>协议框架太宽泛,造成各种实现的兼容性和相互操作性差</li><li>和OAuth1.0不兼容</li><li>OAuth2.0<strong>不是一个认证协议(是授权协议)</strong> ,OAuth2.0本身并不能告诉你任何用户信息.</li></ul><h2 id="OAuth2-0-的授权模式"><a href="#OAuth2-0-的授权模式" class="headerlink" title="OAuth2.0 的授权模式"></a>OAuth2.0 的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得访问令牌（access token）。</p><p>OAuth 2.0 规定了四种获得令牌的流程，可以选择实际情况选择最适合的一种，向第三方应用颁发令牌。</p><ul><li><strong>授权码模式（authorization-code）</strong>：正宗方式，支持refresh_token</li><li><strong>简化模式（implicit）</strong>:  为web浏览器应用设计，不支持refresh_token</li><li><strong>密码模式（password）</strong>:  为遗留系统设计，支持refresh_token</li><li><strong>客户端模式（client credentials）</strong>：为后台api服务设计，不支持refresh_token</li></ul><table><thead><tr><th><span style= "display:inline-block;width:100px">授权模式</span></th><th><span style= "display:inline-block;width:80px">优点</span></th><th><span style= "display:inline-block;width:100px">缺点</span></th><th><span style= "display:inline-block;width:100px">备注</span></th></tr></thead><tbody><tr><td>授权码模式</td><td>Access token通过服务器之间进行交换，比较安全</td><td>请求次数比较多</td><td>推荐该模式</td></tr><tr><td>简化模式</td><td>请求次数比较少，简单</td><td>1.没有获取code的过程， Access token直接从授权服务器返回给client客户端，<strong>令牌容易因为被拦截窃听而泄露</strong>                                                                               2.无法存储refresh token，不支持刷新令牌： 要么access token有效性给很长 要么access token过期后，让用户重新认证</td><td>适用于公开的浏览器单页应用</td></tr><tr><td>密码模式</td><td>请求次数比较少，简单</td><td>1.Client会获得用户的登录信息，除非是非常信任的应用，否则可能导致登录信息泄露。                                                                                                                     2.没有多因子认证这样的机制。</td><td>1.可以用来做遗留项目升级OAuth2的适配方案 2.Client是自家应用的场景</td></tr><tr><td>客户端模式</td><td></td><td></td><td></td></tr></tbody></table><p>不管哪一种授权方式，第三方应用<em>申请令牌之前，都必须先到系统备案</em>，说明自己的身份，然后会拿到两个身份识别码：<strong>客户端 ID（client ID  用来标识第三方应用）和客户端密钥（client secret  用来进行安全加密）</strong>。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p>OAuth2最常用的一种授权许可类型，<strong>要求Client具有可公开访问的Server服务器</strong>来接受Authorization Code </p><p>(适合client具备后端服务器的场景。要求client必须能够安全存储密钥,用于后续使用auth code换access token，需要通过浏览器与终端用户交互完成认证授权。通过浏览器重定向将auth code发送到authorization server，换取access token)</p><ul><li>这种模式算是正宗的OAuth2的授权模式</li><li>设计了Auth code，通过这个code再获取token</li><li>支持refresh token</li></ul><p><img src="https://s1.ax1x.com/2023/05/14/p9cHMH1.png"></p><ol><li>用户登录应用系统，请求跳转到认证服务器，并302返回登录认证页面；</li><li>用户输入账户+密码进行认证，认证服务器认证通过返回code给应用系统；</li><li>应用系统携带code向认证服务器换取访问令牌，认证服务器验证Client ID，code等信息，给应用系统发送访问令牌；</li><li>应用系统携带访问令牌查询用户登录信息，认证服务器返回用户信息，如用户名；</li><li>应用系统验证用户名正确，创建会话，并跳转到redirect url。</li></ol><h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>省略掉了颁发授权码（Authorization Code）给客户端的过程，直接返回访问令牌和可选的刷新令牌。<strong>其适用于没有Server服务器来接受处理Authorization Code的第三方应用。</strong> </p><p><img src="https://s1.ax1x.com/2023/05/14/p9cHYge.png"></p><h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>这种模式再一步简化，和Authorzation Code类型下重要的区分就是<strong>省略了Authorization  Request和Authorization Response</strong>。</p><p>而是<strong>Client直接使用Resource  owner提供的username和password来直接请求access_token</strong>（直接发起Access Token  Request然后返回Access Token Response信息）。这种模式一般<strong>适用于Resource  server高度信任第三方Client的情况下。</strong></p><p><img src="https://s1.ax1x.com/2023/05/14/p9cH0Et.png"></p><h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>Client直接已自己的名义而不是Resource owner的名义去要求访问Resource server的一些受保护资源</p><ul><li><strong>适用于服务器间通信场景</strong>，直接根据client的id和密钥即可获取token，无需用户参与</li><li>这种模式比较适合消费api的后端服务，比如拉取一组用户信息等</li><li>不支持refresh token</li></ul><p>Refresh token的初衷主要是为了用户体验不想用户重复输入账号密码来换取新token，因而设计了refresh  token用于换取新token，客户端模式由于没有用户参与，而且也不需要用户账号密码，仅仅根据自己的id和密钥就可以换取新token，因而没必要refresh token.</p><p><img src="https://s1.ax1x.com/2023/05/14/p9cHy8S.png"></p><h2 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h2><p>以便在访问令牌过期失效的时候可以由客户端自动获取新的访问令牌，而不是让用户再次登录授权。</p><p><img src="https://s1.ax1x.com/2023/05/14/p9cHcvQ.png"></p><p>参考链接</p><blockquote><p>[1]<a href="https://developer.aliyun.com/article/808319#slide-2">https://developer.aliyun.com/article/808319#slide-2</a></p><p>[2]<a href="https://help.aliyun.com/document_detail/174227.html">https://help.aliyun.com/document_detail/174227.html</a></p><p>[3]<a href="https://blog.csdn.net/qq_26878363/article/details/115394602">https://blog.csdn.net/qq_26878363/article/details/115394602</a></p><p>[4]<a href="https://blog.csdn.net/luo15242208310/article/details/120223634">https://blog.csdn.net/luo15242208310/article/details/120223634</a></p><p>[5]<a href="https://blog.csdn.net/luo15242208310/article/details/123596841">https://blog.csdn.net/luo15242208310/article/details/123596841</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>SSO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth</tag>
      
      <tag>SSO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2021/10/08/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/10/08/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>这里主要是hexo文档中常见的一些命令，在使用hexo+github来搭建和使用博客时，也会使用其中的命令，这里做一个总结。</p><span id="more"></span><p>最近忙完了近一年来最重要的事情，开始有了比较多的时间来自我支配，博客几年前就搭建好了，但是一直没有管理，终于能够做一下自己一直想做的事情了。</p><h2 id="hexo-官方文档"><a href="#hexo-官方文档" class="headerlink" title="hexo 官方文档"></a><a href="https://hexo.io/zh-cn/docs/commands.html">hexo 官方文档</a></h2><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo init [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--path</code></td><td>自定义新文章的路径</td></tr><tr><td><code>-r</code>, <code>--replace</code></td><td>如果存在同名文章，将其替换</td></tr><tr><td><code>-s</code>, <code>--slug</code></td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-keyword">new</span> page <span class="hljs-comment">--path about/me</span><br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deploy</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr><tr><td><code>-b</code>, <code>--bail</code></td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td>强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td><code>-c</code>, <code>--concurrency</code></td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--port</code></td><td>重设端口</td></tr><tr><td><code>-s</code>, <code>--static</code></td><td>只使用静态文件</td></tr><tr><td><code>-l</code>, <code>--log</code></td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>, <code>--generate</code></td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-o</code>, <code>--output</code></td><td>设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><hr><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hexo">hexo new &quot;postName&quot; #新建文章<br>hexo new page &quot;pageName&quot; #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）<br>hexo deploy #部署到GitHub  <br>hexo help  # 查看帮助<br>hexo version  #查看Hexo的版本<br></code></pre></td></tr></table></figure><p>缩写</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">hexo n <span class="hljs-operator">=</span><span class="hljs-operator">=</span> hexo new<br>hexo g <span class="hljs-operator">=</span><span class="hljs-operator">=</span> hexo generate<br>hexo s <span class="hljs-operator">=</span><span class="hljs-operator">=</span> hexo server<br>hexo d <span class="hljs-operator">=</span><span class="hljs-operator">=</span> hexo deploy<br></code></pre></td></tr></table></figure><p>组合命令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> s -g <span class="hljs-comment">#生成并本地预览</span><br>hexo d -g <span class="hljs-comment">#生成并上传</span><br></code></pre></td></tr></table></figure><h3 id="本地生成md文件"><a href="#本地生成md文件" class="headerlink" title="本地生成md文件"></a>本地生成md文件</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;postName&quot;</span> <span class="hljs-meta">#新建文章</span><br></code></pre></td></tr></table></figure><p>默认生成内容为</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: hexo常用命令<br>date: 2021<span class="hljs-string">-10</span><span class="hljs-string">-08</span> 09:43:05<br><span class="hljs-keyword">tags:</span><br></code></pre></td></tr></table></figure><p>一般完整格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: postName #文章页面上的显示名称，一般是中文<br>date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改<br>categories: 默认分类 #分类<br>tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格<br>description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面<br><span class="hljs-section">hide: [true/flase] 隐藏文章</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="如何让博文列表不显示全部内容"><a href="#如何让博文列表不显示全部内容" class="headerlink" title="如何让博文列表不显示全部内容"></a>如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，在合适的位置加上<code>&lt;!--more--&gt;</code>即可让博客不显示全部内容，显示效果如下：</p><p><img src="https://z3.ax1x.com/2021/10/09/5FzwND.png"></p><p>参考</p><p>[1] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98</a></p><p>[2] <a href="https://hexo.io/zh-cn/docs/commands.html">https://hexo.io/zh-cn/docs/commands.html</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>miracl椭圆曲线函数</title>
    <link href="/2020/12/26/miracl%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%87%BD%E6%95%B0/"/>
    <url>/2020/12/26/miracl%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>对miracl库中关于椭圆曲线的函数进行总结。</p><span id="more"></span><h2 id="miracl椭圆曲线函数"><a href="#miracl椭圆曲线函数" class="headerlink" title="miracl椭圆曲线函数"></a>miracl椭圆曲线函数</h2><h4 id="ebrick-init"><a href="#ebrick-init" class="headerlink" title="ebrick_init"></a>ebrick_init</h4><p>函数原型：BOOL ebric_init(binst,x,y,a,b,n,w,nb)</p><p>参数类型：ebrick *binst;   big x,y; big a,b,n;  int w,nb;</p><p>参数意义：指向当前实例binst的指针，线上的不动点G&#x3D;（x，y），y2&#x3D;x3+ax+b，模n，以及指数nb中要使用的最大位数</p><p>函数作用：曲初始化一个计算前GF(p)椭圆曲线乘法的梳状方法的实例，内部内存被分配给2^w个椭圆曲线点，这些点将被用于计算和存储</p><p>返回值：如果一切顺利，则返回TRUE；如果出现问题，返回FALSE。</p><h4 id="ebrick2-init"><a href="#ebrick2-init" class="headerlink" title="ebrick2_init"></a>ebrick2_init</h4><p>函数原型：BOOL ebrick2_init(binst,x,y,A,B,m,a,b,c,nb)</p><p>参数类型：ebrick2 *binst;  big x,y;   big A,B;    int m,a,b,c,nb; </p><p>参数意义：指向当前实例binst的指针、曲线y2 + xy &#x3D; x3 + Ax2 +  B上的固定点G&#x3D;(x，y)、字段参数m、a、B、c以及指数nb中要使用的最大位数。对于三项式基础，设置b &#x3D; 0。</p><p>函数作用：初始化带预计算的GF（2m）椭圆曲线乘法的梳状法实例</p><p>返回值：如果一切顺利，则返回TRUE；如果出现问题，返回FALSE</p><h4 id="ecurve-add"><a href="#ecurve-add" class="headerlink" title="ecurve_add"></a>ecurve_add</h4><p>函数原型： void ecurve_add(p,pa) </p><p>参数类型： epoint  *p,*pa; </p><p>函数作用：(素域上)点的加法运算，pa&#x3D;pa+p</p><h4 id="ecurve2-add"><a href="#ecurve2-add" class="headerlink" title="ecurve2_add"></a>ecurve2_add</h4><p>函数原型：void ecurve2_add(p,pa) </p><p>参数类型：epoint *p,*pa;</p><p>函数作用：在GF(2^m)椭圆曲线上. pa&#x3D;pa+p</p><h4 id="ecurve-init"><a href="#ecurve-init" class="headerlink" title="ecurve_init"></a>ecurve_init</h4><p>函数原型：void ecurve_init(A,B,p,type) </p><p>参数类型：big A,B,p;   int type; </p><p>函数作用：初始化当前活动GF(p)椭圆曲线的内部参数，y2 &#x3D;x3 + Ax + B mod p，type为MR_PROJECTIVE or  MR_AFFINE,</p><h4 id="ecurve2-init"><a href="#ecurve2-init" class="headerlink" title="ecurve2_init"></a>ecurve2_init</h4><h4 id="ecurve-mult"><a href="#ecurve-mult" class="headerlink" title="ecurve_mult"></a>ecurve_mult</h4><p>函数原型：void ecurve_mult(k,p,pa)</p><p>参数类型： big k;   epoint  *p,*pa; </p><p>函数作用：将GP(p)椭圆曲线上的点乘以一个整数, pa&#x3D;k*p.  </p><h4 id="ecurve2-mult"><a href="#ecurve2-mult" class="headerlink" title="ecurve2_mult"></a>ecurve2_mult</h4><h4 id="ecurve-mult2"><a href="#ecurve-mult2" class="headerlink" title="ecurve_mult2"></a>ecurve_mult2</h4><p>函数原型：void ecurve_mult2(k1,p1,k2,p2,pa) </p><p>参数类型：big k1,k2;  epoint *p1,*p2,*pa; </p><p>函数作用：点乘加快速运算。计算GF(p)椭圆曲线上的点k1*p1+k2*p2。这比进行两次单独的乘法和加法要快。 pa &#x3D; k1*p1+k2*p2 </p><h4 id="ecurve2-mult2"><a href="#ecurve2-mult2" class="headerlink" title="ecurve2_mult2"></a>ecurve2_mult2</h4><h4 id="ecurve-multi-add"><a href="#ecurve-multi-add" class="headerlink" title="ecurve_multi_add"></a>ecurve_multi_add</h4><p>函数原型：void ecurve_multi_add(m,x,w) </p><p>参数类型：int m; epoint **x,**w; </p><p>函数作用： w[i]&#x3D;w[i]+x[i] , i &#x3D;0 - m-1 （使用仿射坐标）</p><h4 id="ecurve2-multi-add"><a href="#ecurve2-multi-add" class="headerlink" title="ecurve2_multi_add"></a>ecurve2_multi_add</h4><h4 id="ecurve-multn"><a href="#ecurve-multn" class="headerlink" title="ecurve_multn"></a>ecurve_multn</h4><p>函数原型：void ecurve_multn(n,k,p,pa) </p><p>参数类型： int n;  big *k; epoint **p</p><p>参数意义：整数n，n个大数字k[]的数组，n个点的数组。结果在pa中返回。</p><p>函数作用：在GF(p)上计算 k[0]*p[0] + k[1]*p[1] + … + k[n-1]*p[n-1] , n&gt;2</p><h4 id="ecurve2-multn"><a href="#ecurve2-multn" class="headerlink" title="ecurve2_multn"></a>ecurve2_multn</h4><h4 id="ecurve-sub"><a href="#ecurve-sub" class="headerlink" title="ecurve_sub"></a>ecurve_sub</h4><p>函数原型：void ecurve_sub(p,pa) </p><p>参数类型：epoint *p,*pa; </p><p>参数意义：GF（p）上两点</p><p>函数作用：pa &#x3D; pa-p. </p><h4 id="ecurve2-sub"><a href="#ecurve2-sub" class="headerlink" title="ecurve2_sub"></a>ecurve2_sub</h4><h4 id="epoint-comp"><a href="#epoint-comp" class="headerlink" title="epoint_comp"></a>epoint_comp</h4><p>函数原型：BOOL epoint_comp(p1,p2)</p><p>参数类型：epoint\ *p1,*p2; </p><p>函数作用：比较当前在GF(p)椭圆曲线上的两点</p><p>返回值：如果点数相同，则返回TRUE，否则返回ALSE。</p><h4 id="epoint2-comp"><a href="#epoint2-comp" class="headerlink" title="epoint2_comp"></a>epoint2_comp</h4><h4 id="epoint-copy"><a href="#epoint-copy" class="headerlink" title="epoint_copy *"></a>epoint_copy *</h4><p>函数原型：void epoint_copy(p1,p2) </p><p>参数类型：epoint *p1,*p2; </p><p>函数作用：将GF(p)椭圆曲线上的一个点复制到另一个点,p2&#x3D;p1</p><h4 id="epoint2-copy"><a href="#epoint2-copy" class="headerlink" title="epoint2_copy *"></a>epoint2_copy *</h4><h4 id="epoint-free"><a href="#epoint-free" class="headerlink" title="epoint_free *"></a>epoint_free *</h4><p>函数原型：void epoint_free(p) </p><p>参数类型：epoint *p; </p><p>函数作用：释放与GF(p)椭圆曲线上的点p相关联的内存</p><h4 id="epoint-get"><a href="#epoint-get" class="headerlink" title="epoint_get"></a>epoint_get</h4><p>???</p><p>函数原型：int epoint_get(p,x,y) </p><p>参数类型：epoint *p; big x,y; </p><p>函数作用：取出p点的x,y坐标</p><p>返回值：y的最低有效位</p><h4 id="epoint2-get"><a href="#epoint2-get" class="headerlink" title="epoint2_get"></a>epoint2_get</h4><h4 id="epoint-getxyz"><a href="#epoint-getxyz" class="headerlink" title="epoint_getxyz"></a>epoint_getxyz</h4><p>函数原型：void epoint_getxyz(p,x,y,z) </p><p>参数类型：epoint *p; big x,y,z; </p><p>函数作用：提取活动**GF(p)**椭圆曲线上一点的原始(x，y，z)坐标</p><h4 id="epoint2-getxyz"><a href="#epoint2-getxyz" class="headerlink" title="epoint2_getxyz"></a>epoint2_getxyz</h4><h4 id="epoint-init"><a href="#epoint-init" class="headerlink" title="epoint_init"></a>epoint_init</h4><p>函数原型：epoint* epoint_init() </p><p>函数作用：将内存分配给GF(p)椭圆曲线上的一个点，并将其<strong>初始化为“无穷远点”</strong>。</p><p>返回值:返回epoint类型点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">C=epoint_init();<br></code></pre></td></tr></table></figure><p><strong>确保通过调用该函数初始化的所有椭圆曲线点最终通过调用epoint_free被释放。否则将导致内存泄漏</strong></p><h4 id="epoint-init-mem"><a href="#epoint-init-mem" class="headerlink" title="epoint_init_mem"></a>epoint_init_mem</h4><h4 id="epoint2-norm"><a href="#epoint2-norm" class="headerlink" title="epoint2_norm"></a>epoint2_norm</h4><h4 id="epoint-set"><a href="#epoint-set" class="headerlink" title="epoint_set"></a>epoint_set</h4><p>函数原型： BOOL epoint_set(x,y,lsb,p)</p><p>参数类型： big x,y;   int lsb; epoint *p;</p><p>参数意义：</p><p>函数作用：设置点p的（x,y）坐标，（x,y）在曲线上则返回true</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">p=epoint_init(); <br>epoint_set(x,x,<span class="hljs-number">1</span>,p); <br>    <span class="hljs-comment">/* decompress p */</span><br></code></pre></td></tr></table></figure><h4 id="epoint2-set"><a href="#epoint2-set" class="headerlink" title="epoint2_set"></a>epoint2_set</h4><h4 id="epoint-x"><a href="#epoint-x" class="headerlink" title="epoint_x"></a>epoint_x</h4><p>函数原型： BOOL epoint_x(x) </p><p>参数类型：big x; </p><p>函数作用：测试参数x是否是曲线上一点的有效坐标。用这种方法先测试一个x坐标，要比直接通过调用epoint_set在曲线上设置快，因为这样可以避免昂贵的模平方根。</p><p>返回值:如果x是曲线点的坐标，则为真，否则为假</p><h4 id="mul-brick"><a href="#mul-brick" class="headerlink" title="mul_brick"></a>mul_brick</h4><h4 id="mul2-brick"><a href="#mul2-brick" class="headerlink" title="mul2_brick"></a>mul2_brick</h4><h4 id="point-at-infinity"><a href="#point-at-infinity" class="headerlink" title="point_at_infinity *"></a>point_at_infinity *</h4><p>函数原型：BOOL point_at_infinity(p) </p><p>参数类型：epoint *p; </p><p>函数作用：测试椭圆曲线点是否是“无穷远点”。</p><p>返回值：如果p是无穷远点，则为True，否则为false</p><h4 id="sha256-init"><a href="#sha256-init" class="headerlink" title="sha256_init"></a>sha256_init</h4><p>函数原型：sha256_init(psh)</p><p>参数类型：sha256 *psh</p><p>函数功能：初始化安全哈希算法SHA-256的实例。必须在重新使用前调用。</p><h4 id="sha256-process"><a href="#sha256-process" class="headerlink" title="sha256_process"></a>sha256_process</h4><p>函数原型：void shs256_process(psh,ch)</p><p>参数类型：sha256 *psh; int ch;</p><p>函数功能：处理单个字节。通常调用多次以向哈希进程提供输入。所有已处理字节的哈希值可通过后续调用shs256_hash来检索。</p><h4 id="sha256-hash"><a href="#sha256-hash" class="headerlink" title="sha256_hash"></a>sha256_hash</h4><p>函数原型：void shs256_hash(psh,hash)</p><p>参数类型：sha256 *psh; char hash[32];</p><p>函数功能：在提供的数组中生成一个32字节（256位）的哈希值</p><p>参考文献：</p><p>1.官方文档</p><p>2.<a href="https://www.cnblogs.com/Higgerw/p/10164179.html">https://www.cnblogs.com/Higgerw/p/10164179.html</a></p><p>3.<a href="https://blog.csdn.net/weixin_30734435/article/details/95364200">https://blog.csdn.net/weixin_30734435/article/details/95364200</a></p>]]></content>
    
    
    <categories>
      
      <category>cryptography</category>
      
      <category>handbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cryptography</tag>
      
      <tag>skills</tag>
      
      <tag>miracl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mircal常用函数手册</title>
    <link href="/2020/12/21/mircal%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%8C/"/>
    <url>/2020/12/21/mircal%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>由于最近做实验需要使用miracl库，所以对miracl库中常用的函数进行总结。</p><span id="more"></span><h2 id="mircal常用函数手册"><a href="#mircal常用函数手册" class="headerlink" title="mircal常用函数手册"></a>mircal常用函数手册</h2><h4 id="absol"><a href="#absol" class="headerlink" title="absol"></a>absol</h4><p>函数原型：void absol(x,y)</p><p>flash x,y  or  big x,y</p><p>功能：取x的绝对值，y&#x3D;|x|</p><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>函数原型：void add(x,y,z)</p><p>参数类型：big x,y,z</p><p>功能：z&#x3D;x+y</p><h4 id="brand"><a href="#brand" class="headerlink" title="brand"></a>brand</h4><p>函数原型：int brand()</p><p>功能：返回值一个随机整数</p><p>限制：首次使用前必须先调用irand。</p><p>注意：此生成器的加密能力不强。对于加密应用程序，请使用强例程。</p><h4 id="bigbits"><a href="#bigbits" class="headerlink" title="bigbits"></a>bigbits</h4><p>函数原型：void bigbits(n,x)</p><p>参数类型：int n, big x</p><p>功能：产生一个n位的大整数，初始化随机种子由irand函数实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">irand(time(<span class="hljs-literal">NULL</span>));（头文件<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span>）</span><br></code></pre></td></tr></table></figure><h4 id="big-to-bytes"><a href="#big-to-bytes" class="headerlink" title="big_to_bytes"></a>big_to_bytes</h4><p>函数原型：int <strong>big_to_bytes</strong>(max,x,ptr,justify)</p><p>参数类型：int max;big x;char *ptr;BOOL justify</p><p>功能：描述：将正数x转换为二进制八位字符串</p><p>参数：大数字x和字节数组ptr，长度最大。进行错误检查，以确保函数在最大值&gt;0时不会超出ptr的限制。如果max&#x3D;0，则不执行检查。如果max&gt;0且justify&#x3D;TRUE，则输出将正确对齐，否则将抑制前导零。</p><p>返回值：在ptr中生成的字节数。如果justify&#x3D;TRUE，则返回值为max。</p><p>限制：如果“正当性”为TRUE，则最大值必须大于0</p><h4 id="bytes-to-big"><a href="#bytes-to-big" class="headerlink" title="bytes_to_big"></a>bytes_to_big</h4><p>函数原型：void bytes_to_big(len,ptr,x)</p><p>参数类型：int len;  char *ptr;  big x;</p><p>功能：将二进制八位字节字符串转换为大数字。二进制到大的转换。</p><p>参数：指向长度为len的字节数组ptr的指针，以及一个大的结果x。</p><h4 id="—cinnum"><a href="#—cinnum" class="headerlink" title="—cinnum"></a>—cinnum</h4><p>函数原型：int cinnum(x,f)</p><p>参数类型：flash x; FILE *f</p><p>描述:从键盘或文件中输入一个flash数字，以实例变量IOBASE的当前值作为基数。可以使用斜杠“&#x2F;”来表示分子和分母，也可以使用基数点输入闪存数。</p><p>参数：一个big&#x2F;flash数字x和一个文件描述符f。从键盘输入时，将f指定为stdin，否则指定为其他打开文件的描述符。要强制输入固定数量的字节，请在调用cinnum之前将实例变量INPLEN设置为所需的数量。</p><p>返回值：输入字符数。</p><h4 id="cinstr"><a href="#cinstr" class="headerlink" title="cinstr"></a>cinstr</h4><p>函数原型：int cinstr(x,s)</p><p>参数类型：flash x; char *s</p><p>功能说明: 将大数字符串转换成大数</p><p>参数：一个大的&#x2F;flash数字x和一个字符串s。</p><p>返回值：输入字符数</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">mip-&gt;IOBASE=<span class="hljs-number">16</span>; <span class="hljs-comment">// input large hex number into big x</span><br>cinstr(x,”AF12398065BFE4C96DB723A”);<br></code></pre></td></tr></table></figure><h4 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h4><p>函数原型：int compare(x,y)</p><p>参数类型：big x; big y</p><p>函数功能：比较两个大数的大小</p><p>返回值：x&gt;y时返回+1, x&#x3D;y时返回0, x&lt;y时返回-1  在这里需要注意的是，compare()函数比较的是两个big类型的数，此函数的返回值是int型的+1和-1   </p><p>注意:if(1)和if(-1)的结果相同</p><h4 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h4><p>函数原型：void convert (n,x)</p><p>参数类型：int n; big x</p><p>函数功能：将一个整数n转换成一个大数x</p><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>函数原型：void <strong>copy</strong>(big x, big y);</p><p>参数类型：flash x,y     big x ,y</p><p>函数功能：y&#x3D;x</p><h4 id="cotnum"><a href="#cotnum" class="headerlink" title="cotnum"></a>cotnum</h4><p>函数原型：int cotnum(x,f)</p><p>参数类型：flash x;FILE *f</p><p>描述：将当前分配给实例变量IOBASE的值作为基数，输出一个大的或闪烁的数字到屏幕或文件中。如果实例变量RPOINT&#x3D;ON，则flash数字将转换为基数点表示。否则它将作为分数输出。</p><p>参数一个大的&#x2F;闪存号x和一个文件描述符f。如果f是stdout，则输出到屏幕，否则输出到用描述符f打开的文件。</p><p>返回值：输出字符数。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mip-&gt;IOBASE=<span class="hljs-number">16</span>;<br>cotnum(x,fp);<br><span class="hljs-comment">//This outputs x in hex, to the file associated with fp. </span><br></code></pre></td></tr></table></figure><h4 id="cotstr"><a href="#cotstr" class="headerlink" title="cotstr"></a>cotstr</h4><p>函数原型：int cotstr(x,s)</p><p>参数类型：flash x; char *s</p><p>函数功能：将一个大数根据其进制转换成一个字符串</p><p>返回值: 字符串长度</p><h4 id="decr"><a href="#decr" class="headerlink" title="decr"></a>decr</h4><p>函数原型：void decr(x,n,z)</p><p>参数类型：big x,z; int n</p><p>功能说明: 将一个大数减去一个整数， z&#x3D;x-n.</p><h4 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h4><p>函数原型：void divide(x,y,z)</p><p>参数类型：big x,y,z</p><p>功能：两个大数相除，z&#x3D;x&#x2F;y; x&#x3D;x mod y，当变量y和z相同时，x为余数，商不返回（即y的值不变）；当x和z相同时，x为商，余数不返回。</p><p>注意：Example:  divide(x,y,y);&#x2F;&#x2F;x为余数，y值不</p><h4 id="ecp-memalloc"><a href="#ecp-memalloc" class="headerlink" title="ecp_memalloc"></a>ecp_memalloc</h4><h4 id="ecp-memkill"><a href="#ecp-memkill" class="headerlink" title="ecp_memkill"></a>ecp_memkill</h4><h4 id="exsign"><a href="#exsign" class="headerlink" title="exsign"></a>exsign</h4><h4 id="getdig"><a href="#getdig" class="headerlink" title="getdig"></a>getdig</h4><p>函数原型：int getdig(x,i)</p><p>参数类型：big x; int i</p><p>描述：从一个大数字中提取一个数字。</p><p>参数：一个大的数字x，和所需的数字i。</p><p>返回值：请求的数字的值。</p><p>限制：如果所需数字不存在，则返回垃圾。</p><h4 id="igcd"><a href="#igcd" class="headerlink" title="igcd"></a>igcd</h4><p>函数原型：int igcd(x,y)</p><p>参数类型：int x,y</p><p>功能：使用欧几里德方法计算两个整数的最大公约数</p><p>返回值：x和y的GCD</p><h4 id="incr"><a href="#incr" class="headerlink" title="incr"></a>incr</h4><p>函数原型：void incr(x,n,z)</p><p>参数类型：big x,z  ;    int n</p><p>功能：z&#x3D;x+n</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">incr（x，<span class="hljs-number">2</span>，x）；<span class="hljs-comment">/*这将使x增加2。*/</span><br></code></pre></td></tr></table></figure><h4 id="innum"><a href="#innum" class="headerlink" title="innum"></a>innum</h4><p>函数原型：int innum(x,f)</p><p>参数类型：flash x; FILE *f</p><h4 id="insign"><a href="#insign" class="headerlink" title="insign"></a>insign</h4><p>函数原型：void insign(s,x)</p><p>参数类型：int s; flash x</p><p>功能:</p><h4 id="instr"><a href="#instr" class="headerlink" title="instr"></a>instr</h4><p>函数原型：int instr(x,s)</p><p>参数类型：flash x; char *s</p><p>功能：</p><h4 id="irand"><a href="#irand" class="headerlink" title="irand"></a>irand</h4><p>函数原型：void irand(seed)</p><p>参数类型：long seed</p><p>功能：初始化内部随机数系统</p><h4 id="lgconv"><a href="#lgconv" class="headerlink" title="lgconv"></a>lgconv</h4><p>函数原型：void lgconv(ln,x)</p><p>参数类型：long ln; big x</p><p>功能：将长整数转换为大数格式</p><h4 id="mad"><a href="#mad" class="headerlink" title="mad"></a>mad</h4><p>函数原型：void mad(x,y,z,w,q,r)</p><p>参数类型：big x,y,z,w,q,r</p><p>功能：<em>q&#x3D;(x.y+z)&#x2F;w</em>，r为余数，如果w和q不是不同的变量，则只返回余数；如果q和r不是不同的，则只返回商。如果x和z（或y和z）相同，则不会进行z的加法。</p><h4 id="memalloc"><a href="#memalloc" class="headerlink" title="memalloc"></a>memalloc</h4><p>函数原型：void  *memalloc(n)</p><p>参数类型：int n</p><p>功能：：在一个堆访问中为n个大变量保留空间。随后，可以通过调用mirvar_mem从该内存初始化单个大&#x2F;闪存变量</p><p>返回值：指向已分配内存的指针</p><h4 id="memkill"><a href="#memkill" class="headerlink" title="memkill"></a>memkill</h4><p>函数原型：void memkill(mem,n)</p><p>参数类型：char *mem; int n</p><p>功能：删除memalloc先前分配的内存并将其设置为</p><h4 id="mirexit"><a href="#mirexit" class="headerlink" title="mirexit"></a>mirexit</h4><p>函数原型：void mirexit()</p><p>功能：在MIRACL的当前实例之后清理，并释放所有内部变量。随后调用mirsys将重新初始化MIRACL系统（清除MIRACL系统，释放所有内部变量）</p><h4 id="mirkill"><a href="#mirkill" class="headerlink" title="mirkill"></a>mirkill</h4><p>函数原型：void mirkill(x)</p><p>参数类型：big x</p><p>功能： 释放内存大数所占的内存    清除MIRACL系统，释放所有内部变量。</p><h4 id="mirsys"><a href="#mirsys" class="headerlink" title="mirsys"></a>mirsys</h4><p>函数原型：miracl *mirsys（nd,nb）</p><p>参数类型：int nd,nb</p><p>功能：初始化MIRACL系统，该函数必须在调用MIRACL库函数之前先执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"> miracl *mip=mirsys(<span class="hljs-number">500</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//初始化500位的10进行制数</span><br><span class="hljs-comment">//意思是我定义的这些变量最大长度都是500位（这个位是后面进制的位数），输入、输出、运算用的进制都是10进制。</span><br></code></pre></td></tr></table></figure><h4 id="mirvar"><a href="#mirvar" class="headerlink" title="mirvar"></a>mirvar</h4><p>函数原型：flash mirvar(iv)</p><p>参数类型：int iv</p><p>功能：通过为big&#x2F;flash变量保留适当数量的内存位置来初始化该变量。这个内存可以通过随后调用mirkill函数来释放</p><p>eg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">flash x;<br>x=mirvar(<span class="hljs-number">8</span>);<br><span class="hljs-comment">//Creates a flash variable x=8.</span><br><br></code></pre></td></tr></table></figure><h4 id="mirvar-mem"><a href="#mirvar-mem" class="headerlink" title="mirvar_mem"></a>mirvar_mem</h4><p>函数原型：flash mirvar_mem(mem,index)</p><p>参数类型：char *mem； int index</p><p>功能：从预先分配的字节数组mem初始化big&#x2F;flash变量的内存</p><p>返回值：初始化的big&#x2F;flash变量</p><p>限制：mem必须已经分配并指向足够的内存</p><h4 id="multiply"><a href="#multiply" class="headerlink" title="multiply"></a>multiply</h4><p>函数原型：void multiply(x,y,z)</p><p>参数类型：big x,y,z</p><p>功能：z&#x3D;x*y</p><h4 id="negify"><a href="#negify" class="headerlink" title="negify"></a>negify</h4><p>函数原型：void negify(x,y)</p><p>参数类型：flash x,y</p><p>功能：大数取反，y&#x3D;-x</p><h4 id="normalise"><a href="#normalise" class="headerlink" title="normalise"></a>normalise</h4><p>函数原型：int normalise(x,y)</p><p>参数类型：big x,y</p><p>功能：y&#x3D;nx</p><p>返回值：n</p><h4 id="nroot"><a href="#nroot" class="headerlink" title="nroot"></a>nroot</h4><p>函数原型：BOOL <strong>nroot</strong>(x,n,z)</p><p>参数类型：big x,z; int n;</p><p>功能：$z&#x3D;\lfloor x^{1&#x2F;n} \rfloor$ </p><p>返回值；如果找到的根是精确的，则返回布尔值TRUE，否则返回FALSE。</p><h4 id="numdig"><a href="#numdig" class="headerlink" title="numdig"></a>numdig</h4><p>函数原型：int numdig(x)</p><p>参数类型：big x</p><p>功能：返回大数x中数字的个数（位数）</p><h4 id="otnum"><a href="#otnum" class="headerlink" title="otnum"></a>otnum</h4><p>函数原型：int otnum(x,f)</p><p>参数类型：flash x; FILE *f</p><p>功能：使用mirsys初始调用中指定的值作为基数，向屏幕或文件输出一个big或flash数字   如果实例变量RPOINT&#x3D;ON，则flash数字将转换为基数点表示。否则它将作为分数输出</p><p>返回值：输出字符数。</p><p>限制：mirsys中指定的基数必须小于或等于256。如果没有，请改用cotnum</p><h4 id="otstr"><a href="#otstr" class="headerlink" title="otstr"></a>otstr</h4><p>函数原型：int otstr(x,s)</p><p>参数类型：flash x; char *s</p><p>功能：将在对mirsys的初始调用中指定的值作为基数，向指定的字符串输出一个大big或flash数字   如果实例变量RPOINT&#x3D;ON，则flash数字将转换为基数点表示。否则它将作为分数输出</p><h4 id="premult"><a href="#premult" class="headerlink" title="premult"></a>premult</h4><p>函数原型：void premult(x,n,z)</p><p>参数类型：int n; big x,z</p><p>功能：z&#x3D;nx</p><h4 id="putdig"><a href="#putdig" class="headerlink" title="putdig"></a>putdig</h4><p>函数原型：void putdig(n,x,i)</p><p>参数类型：big x ; int i,n</p><p>功能：将一个大数的数字设置为给定值  ，n为新值</p><h4 id="remian"><a href="#remian" class="headerlink" title="remian"></a>remian</h4><p>函数原型：int remian(x,n)</p><p>参数类型：big x;int n</p><p>功能：当一个大数除以一个整数时，查找整数余数</p><p>返回值：余数</p><h4 id="set-io-buffer-size"><a href="#set-io-buffer-size" class="headerlink" title="set_io_buffer_size"></a>set_io_buffer_size</h4><p>函数原型：void set_io_buffer_size(len)</p><p>参数类型：int len</p><p>功能：设置输入&#x2F;输出缓冲区的大小。默认设置为1024，但需要处理非常大的数字的程序可能需要更大的I&#x2F;O缓冲区</p><h4 id="—void-set-user-function"><a href="#—void-set-user-function" class="headerlink" title="—void set_user_function"></a>—void set_user_function</h4><p>函数原型：void set_user_function(func)</p><p>参数类型：BOOL (*user)(void)</p><p>功能：提供一个用户指定的函数，该函数在一些比较耗时的MIRACL函数中定期调用，特别是那些涉及模幂运算和寻找大素数的函数</p><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>函数原型：int size(x)</p><p>参数类型：big x</p><p>功能：尝试将大数转换为简单整数。也可用于测试big&#x2F;flash变量的符号</p><h4 id="subdivisible"><a href="#subdivisible" class="headerlink" title="subdivisible"></a>subdivisible</h4><p>函数原型：BOOL subdivisible(x,n)</p><p>参数类型：big x;   int n;</p><p>功能： 测试n能否整除x</p><p>返回值: x除以n余数为0，返回TRUE，否则返回FALSE</p><h4 id="subtract"><a href="#subtract" class="headerlink" title="subtract"></a>subtract</h4><p>函数原型：void subtract(x,y,z)</p><p>参数类型：big x,y,z</p><p>功能：z&#x3D;x-y</p><h4 id="zero"><a href="#zero" class="headerlink" title="zero"></a>zero</h4><p>函数类型：void zero(x)</p><p>参数类型：flash x</p><p>功能：将x置零</p><h4 id="bigdig"><a href="#bigdig" class="headerlink" title="bigdig"></a>bigdig</h4><p>函数原型：void bigdig(n,b,x)</p><p>参数类型：int n,b  ;  big x</p><p>功能：产生一个指定长度的进制的随机数，该函数使用内置的随机数发生器，初始化种子调用irand函数</p><p>x是生成的大数  n位长   b是进制</p><p>eg</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">bigdig（<span class="hljs-number">100</span>,<span class="hljs-number">10</span>,x）；<br><span class="hljs-regexp">//</span>这将生成一个<span class="hljs-number">100</span>位十进制随机数<br></code></pre></td></tr></table></figure><h4 id="bigrand"><a href="#bigrand" class="headerlink" title="bigrand"></a>bigrand</h4><p>函数原型：void bigrand(w,x)</p><p>参数类型：big w,x;</p><p>功能：生成一个大的随机数。使用由irand初始化的内置简单随机数生成器，0&lt;&#x3D;x&lt;w</p><p>两个函数的区别：</p><p>两个函数都是可以生成随机数的，但是它们的功能确实略有差异的。bigrand()是产生一个小于w的大数随机数，x&lt;w，如果w是一个十位的十进制数，那么x可能是一个十位的十进制数，只有九位的十进制数，也可能使只有一位的十进制数；bigdig()是产生一个指定长度的进制的随机数，比如说指定了产生一个十位的十进制数，那么这个函数就会严格的产生一个十位的十进制数。</p><h4 id="egcd"><a href="#egcd" class="headerlink" title="egcd"></a>egcd</h4><p>函数原型：int egcd(x,y,z)</p><p>参数类型：big x,y,z;</p><p>功能：计算两个大数的最大公约数， <em>z&#x3D;gcd(x,y)</em></p><h4 id="expb2"><a href="#expb2" class="headerlink" title="expb2"></a>expb2</h4><p>函数原型：void expb2(n,x)</p><p>参数类型：  int n; big x;</p><p>功能：计算2的n次方的大数  <em>x&#x3D;2^n.</em></p><p>eg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">expb2(<span class="hljs-number">1398269</span>,x);   <span class="hljs-comment">//2^1398269</span><br>            decr(x,<span class="hljs-number">1</span>,x);        <span class="hljs-comment">//x = x - 1</span><br>            mip-&gt;IOBASE=<span class="hljs-number">10</span>;     <span class="hljs-comment">//使用10进制</span><br>            cotnum(x,<span class="hljs-built_in">stdout</span>);   <span class="hljs-comment">//输出到屏幕</span><br></code></pre></td></tr></table></figure><h4 id="expint"><a href="#expint" class="headerlink" title="expint"></a>expint</h4><p>函数原型：void expint（b, n, x）</p><p>参数类型：int b,n;  big x;</p><p>功能：计算b的n次方的大数  <em>x&#x3D;b^n.</em></p><h4 id="fft-mult"><a href="#fft-mult" class="headerlink" title="fft_mult"></a>fft_mult</h4><p>函数原型：void <strong>fft_mult</strong>(x,y,z)</p><p>参数类型：big x,y,z;</p><p>功能：使用Fast Fourier算法计算两个大数乘积，z&#x3D;x*y</p><h4 id="gprime"><a href="#gprime" class="headerlink" title="gprime"></a>gprime</h4><p>函数原型：void gprime(n)</p><p>参数类型：int n</p><p>功能：将达到某个限制的所有素数生成实例数组素数，并以零结尾</p><h4 id="hamming"><a href="#hamming" class="headerlink" title="hamming"></a>hamming</h4><p>函数原型：int hamming(n)</p><p>参数类型：big n</p><p>功能：计算一个大数的汉明权重–汉明距离（实际上是二进制表示中的1的数目）</p><h4 id="invers"><a href="#invers" class="headerlink" title="invers"></a>invers</h4><p>函数原型：unsigned int invers(x,y)</p><p>参数原型：unsigned int x,y;</p><p>功能：计算两个无符号整数（要求互素）的模逆，返回<em>x-1 mod y</em></p><h4 id="isprime"><a href="#isprime" class="headerlink" title="isprime"></a>isprime</h4><p>函数原型：BOOL isprime(x)</p><p>参数类型：big x;</p><p>功能：判断一个大数是否为素数，使用概率测试算法</p><p>返回值：x为素数返回TRUE，否则返回FALSE</p><h4 id="jac"><a href="#jac" class="headerlink" title="jac"></a>jac</h4><p>函数原型：int jac(x,n)</p><p>参数类型：unsigned int x,n;</p><p>功能：计算雅可比符号的值</p><h4 id="jack"><a href="#jack" class="headerlink" title="jack"></a>jack</h4><p>函数原型：int jack(x,n)</p><p>参数类型：big x,n</p><p>功能：计算雅可比符号的值</p><h4 id="logb2"><a href="#logb2" class="headerlink" title="logb2"></a>logb2</h4><p>函数原型：int logb2(x)</p><p>参数类型：big x;</p><p>功能： 计算一个大数（实际上是其中的位数）的基数2的近似整数log </p><h4 id="lucas"><a href="#lucas" class="headerlink" title="lucas"></a>lucas</h4><p>函数原型：void lucas(x,e,n,vp,v)</p><p>参数类型：big x,e,n,vp,v</p><p>功能：执行Lucas模幂运算。在内部使用蒙哥马利算法。通过调用特殊的汇编语言例程来实现Montgomery算法，可以为特定的模块进一步加速该函数。见powmod</p><h4 id="power"><a href="#power" class="headerlink" title="power"></a>power</h4><p>函数原型： void power(x,n,z,w)</p><p>参数类型： long n; big x,z,w;</p><p>功能：w&#x3D;xn.如果w≠z则w&#x3D;xn mod z</p><h4 id="powmod"><a href="#powmod" class="headerlink" title="powmod"></a>powmod</h4><p>函数原型：void powmod(x,y,z,w)</p><p>参数类型：big x,y,z,w;</p><p>功能：模幂运算，<em>w&#x3D;x^y mod z</em></p><h4 id="sfbit"><a href="#sfbit" class="headerlink" title="sfbit"></a>sfbit</h4><p>函数原型：void sftbit(x,n,z)</p><p>参数类型：big x,z;int n;</p><p>功能：将一个大数左移或右移n位，n为正数时左移，负数时右移</p><h4 id="xgcd"><a href="#xgcd" class="headerlink" title="xgcd"></a>xgcd</h4><p>函数原型：int xgcd(x,y,xd,yd,z)</p><p>参数类型： big x,y,xd,yd,z;</p><p>功能： 计算两个大数的扩展最大公约数，也可以用来计算模逆，这个函数比<strong>mad</strong> 函数运算速度稍慢。<em>z&#x3D;gcd(x,y)&#x3D;x.xd+y.yd</em></p><p>eg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">xgcd(x,p,x,x,x);  <span class="hljs-comment">//计算x^-1 mod p</span><br><span class="hljs-comment">/* x = 1/x mod p  (p is prime) *</span><br></code></pre></td></tr></table></figure><p><a href="https://wenku.baidu.com/view/1738a6878762caaedd33d4b4.html?sxts=1602327937928&amp;word=miracl%E5%BA%93%E6%89%8B%E5%86%8C">https://wenku.baidu.com/view/1738a6878762caaedd33d4b4.html?sxts=1602327937928&amp;word=miracl%E5%BA%93%E6%89%8B%E5%86%8C</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">xgcd(Mi1, m1, Mj1, Mj1, Mj1);<span class="hljs-comment">//Mj1为Mi1的逆</span><br>xgcd(Mi2, m2, Mj2, Mj2, Mj2);<span class="hljs-comment">//Mj2为Mi2的逆</span><br>xgcd(Mi3, m3, Mj3, Mj3, Mj3);<span class="hljs-comment">//Mj3为Mi3的逆</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//扩展的欧几里得算法</span><br><span class="hljs-comment">//Input</span><br>x = <span class="hljs-number">13</span><br>y = <span class="hljs-number">17</span><br>xgcd(x, y, xd, yd, z)<br><span class="hljs-comment">//Output</span><br>xd = <span class="hljs-number">4</span><br>yd = <span class="hljs-number">3</span><br>z = <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h4 id="实例变量IOBASE"><a href="#实例变量IOBASE" class="headerlink" title="实例变量IOBASE"></a>实例变量IOBASE</h4><p> IOBASE是用于控制输入和输出的进制问题的，可以在程序中随意更改， 必须大于或等于2且小于或等于256。使用实例是像这样的：mip-&gt;IOBASE&#x3D;16，这样子输入的变量和输出的变量所使用的进制都是十六进制</p>]]></content>
    
    
    <categories>
      
      <category>cryptography</category>
      
      <category>handbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cryptography</tag>
      
      <tag>skills</tag>
      
      <tag>miracl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客的搭建（hexo+github）</title>
    <link href="/2019/02/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/02/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h5 id="Hexo-中文官方网站-是一个快速-简洁且高效的博客框架-让上百个页面在几秒内瞬间完成渲染-Hexo支持Github-Flavored-Markdown的所有功能-甚至可以整合Octopress的大多数插件-并自己也拥有强大的插件系统"><a href="#Hexo-中文官方网站-是一个快速-简洁且高效的博客框架-让上百个页面在几秒内瞬间完成渲染-Hexo支持Github-Flavored-Markdown的所有功能-甚至可以整合Octopress的大多数插件-并自己也拥有强大的插件系统" class="headerlink" title="Hexo(中文官方网站)是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统."></a>Hexo(中文官方网站)是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统.</h5><span id="more"></span><h1 id="个人博客搭建过程（github-hexo）"><a href="#个人博客搭建过程（github-hexo）" class="headerlink" title="个人博客搭建过程（github hexo）"></a>个人博客搭建过程（github hexo）</h1><p>Hexo(中文官方网站)是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统.</p><hr><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>git下载（官网）</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://s2.ax1x.com/2019/02/24/k4Q7ff.png"></h5><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><h3 id="下载并安装（建议旧版）"><a href="#下载并安装（建议旧版）" class="headerlink" title="下载并安装（建议旧版）"></a>下载并安装（建议旧版）<img src="https://s2.ax1x.com/2019/02/24/k4l9hV.png"></h3><p>Tip：Custom Setup这一步，点一下Add to Path新建文件夹blog，右击git bash再点next</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>新建文件夹blog，右击git bash，输入以下</p><blockquote><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></blockquote><p>完成后输入</p><blockquote><p>cnpm i -g hexo-cli</p></blockquote><p>  检查hexo版本</p><blockquote><p>hexo  -v</p></blockquote><p><img src="https://s2.ax1x.com/2019/02/24/k4lFcF.png"></p><hr><h2 id="本地搭建博客"><a href="#本地搭建博客" class="headerlink" title="本地搭建博客"></a>本地搭建博客</h2><h3 id="依次输入以下命令"><a href="#依次输入以下命令" class="headerlink" title="依次输入以下命令"></a>依次输入以下命令</h3><blockquote><p>hexo init</p><p>cnpm install</p><p>hexo s <!--生成本地服务--></p></blockquote><h3 id="访问本地博客"><a href="#访问本地博客" class="headerlink" title="访问本地博客"></a>访问本地博客</h3><p>完成以上命令后，访问本地博客<a href="http://localhost:4000/">http://localhost:4000</a></p><p>如果以上步骤均无误，默认博客为以下页面，那么本地博客搭建完毕</p><p><img src="https://s2.ax1x.com/2019/02/24/k4lSkq.png"></p><hr><h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><h3 id="实现git本地管理GitHub"><a href="#实现git本地管理GitHub" class="headerlink" title="实现git本地管理GitHub"></a>实现git本地管理GitHub</h3><p>blog，右击git bash，进入输入如下地址</p><blockquote><p>git config –global user.name “你的github用户名”</p><p>git config –global user.email “你的邮箱”</p></blockquote><p>**tip  ** 注意空格！！！</p><h3 id="创建ssh"><a href="#创建ssh" class="headerlink" title="创建ssh"></a>创建ssh</h3><p> 打开git bash，依次输入</p><blockquote><p>ssh-keygen -t rsa -C your email</p><p>clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</p></blockquote><p>setting-&gt; 添加ssh key</p><p><img src="https://s2.ax1x.com/2019/02/24/k4lkX4.png"></p><p>粘贴密钥至key处（先得注册GitHub账号，需要翻墙注册，且新建的仓库名称要与github用户名对应）点击add ssh key</p><p>回到Gitbash 输入</p><blockquote><p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p></blockquote><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>创建新的储存库</p><p>进入blog文件夹，用编辑器打开，将最后的改成图中的样子（注意：冒号后有空格）</p><p><img src="https://s2.ax1x.com/2019/02/24/k4lPpT.png"></p><p>（其中为github的用户名）</p><h3 id="上传blog到GitHub"><a href="#上传blog到GitHub" class="headerlink" title="上传blog到GitHub"></a>上传blog到GitHub</h3><p>依次输入以下命令</p><blockquote><p>cnpm install hexo-deployer-git –save</p><p>hexo d</p></blockquote><p>现在可以通过   用户名.github.io   进入博客</p><hr><p>2021.10.8  <a href="https://hjxlog.com/posts/20190908a1.html#6-%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D">看到一个不错的博客（介绍如何搭建）</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
