

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/3%20(1).jpg">
  <link rel="icon" href="/img/3%20(1).jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="c++ primer plus第四章，包括数组、字符串、结构体、共用体、枚举、指针与自由存储空间、指针&amp;amp;数组和指针算数、数组的替代品（array和vector）">
  <meta name="author" content="Yankel">
  <meta name="keywords" content="">
  <meta name="description" content="c++ primer plus第四章，包括数组、字符串、结构体、共用体、枚举、指针与自由存储空间、指针&amp;数组和指针算数、数组的替代品（array和vector）">
<meta property="og:type" content="article">
<meta property="og:title" content="c++基础知识(3)">
<meta property="og:url" content="http://yankel.github.com/2023/08/11/c++/c-3/index.html">
<meta property="og:site_name" content="Yankel">
<meta property="og:description" content="c++ primer plus第四章，包括数组、字符串、结构体、共用体、枚举、指针与自由存储空间、指针&amp;数组和指针算数、数组的替代品（array和vector）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-11T03:38:09.000Z">
<meta property="article:modified_time" content="2023-08-11T03:40:55.860Z">
<meta property="article:author" content="Yankel">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary_large_image">
  
  <title>c++基础知识(3) - Yankel</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yankel.github.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":"563a1ae07198a9b57a53f93c88e5f1ed","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yank3l&#39;s universe</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/1%20(9).jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="c++基础知识(3)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-08-11 11:38" pubdate>
        2023年8月11日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.8k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      24 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">c++基础知识(3)</h1>
            
            <div class="markdown-body">
              <p>c++ primer plus第四章，包括数组、字符串、结构体、共用体、枚举、指针与自由存储空间、指针&amp;数组和指针算数、数组的替代品（array和vector）</p>
<span id="more"></span>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>能够存储多个<u>同类型</u>的值，在内存中连续排布。</p>
<p>数组声明：存储在每个元素中的值的类型；数组名；元素数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">typeName arrayName[arraySize]<br>such as <span class="hljs-type">short</span> months[<span class="hljs-number">12</span>]<br></code></pre></td></tr></table></figure>

<blockquote>
<p>编译器不会检查使用的下标是否有效，但是程序运行后，可能会引发问题。</p>
</blockquote>
<p>只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> cards[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//√</span><br><span class="hljs-type">int</span> hand[<span class="hljs-number">4</span>];<br>hand[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">//×</span><br>hand = cards; <span class="hljs-comment">//×</span><br></code></pre></td></tr></table></figure>

<p>如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>c++处理字符串的方式有两种，c风格字符串+基于string类库的方法</p>
<h4 id="c风格字符串"><a href="#c风格字符串" class="headerlink" title="c风格字符串"></a>c风格字符串</h4><h5 id="字符串存储在char类型数组"><a href="#字符串存储在char类型数组" class="headerlink" title="字符串存储在char类型数组"></a><strong>字符串存储在char类型数组</strong></h5><p>以空字符（’\0’）结尾–&gt;字符串和字符数组的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> dog[<span class="hljs-number">8</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;; <span class="hljs-comment">//not a string</span><br><span class="hljs-type">char</span> cat[<span class="hljs-number">8</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;; <span class="hljs-comment">//a string</span><br></code></pre></td></tr></table></figure>

<p>用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它。应确保数组足够大，能够存储字符串中所有字符-包括空字符。</p>
<p><code>char bird[11] = &quot;Mr.Cheeps&quot;; // a string</code></p>
<p>单引号’A’是字符常量，双引号”A”是字符串</p>
<p><strong>cin使用空白字符（空格、换行符和制表符）来确定字符串的结束位置</strong>，这意味着cin在获取字符数组输入时只读取一个单词。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>cin &gt;&gt; name;<br><span class="hljs-comment">//输入 Alistair Dreeb时，只会将Alistair存入name数组</span><br></code></pre></td></tr></table></figure>

<h5 id="采用面向行的字符串读取方法"><a href="#采用面向行的字符串读取方法" class="headerlink" title="采用面向行的字符串读取方法"></a><strong>采用面向行的字符串读取方法</strong></h5><p>istream中的类提供了面向行的类成员函数：getline()和get()。这两个函数都读取一行输入，直到到达换行符。然而，随后getline()将丢弃换行符，而get()将换行符保留在输入序列中。</p>
<p>getline()使用起来更简单一些，但get()使得检查错误更简单些。</p>
<ol>
<li><p>getline()</p>
<p>读取整行，通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用cin.getline()。该函数有两个参数：第一个参数是用来存储输入行的数组的名称；第二个参数是要读取的字符数（包括一个空字符’\0’）。getline()成员函数在读取指定书目的字符或遇到换行符时停止读取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin.<span class="hljs-built_in">getline</span>(name,<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>get()</p>
<p>get()函数不再抛弃换行符，而是将其留在输入队列中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin.<span class="hljs-built_in">get</span>(name,<span class="hljs-number">20</span>);<br>cin.<span class="hljs-built_in">get</span>(dessert,<span class="hljs-number">20</span>);<br><span class="hljs-comment">//如果输入Alistair Dreeb，程序会出现问题，这是因为第一次调用之后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符就是换行符，get()便会认为已经到达行尾，而没有发现任何可读取的内容。</span><br></code></pre></td></tr></table></figure>

<p>get()使用不带任何参数的cin.get()调用可读取下一个字符（即使是换行符），因此可以使用它来处理换行符，为读取下一行输入做好准备。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin.<span class="hljs-built_in">get</span>(name,<span class="hljs-number">20</span>);<br>cin.<span class="hljs-built_in">get</span>();<br>cin.<span class="hljs-built_in">get</span>(dessert,<span class="hljs-number">20</span>);<br>等价于<br>cin.<span class="hljs-built_in">get</span>(name,<span class="hljs-number">20</span>).<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="混合输入数字和面向行的字符串会导致问题"><a href="#混合输入数字和面向行的字符串会导致问题" class="headerlink" title="混合输入数字和面向行的字符串会导致问题"></a><strong>混合输入数字和面向行的字符串会导致问题</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    cout &gt;&gt; <span class="hljs-string">&quot;What year was your house built?\n&quot;</span>;<br>    <span class="hljs-type">int</span> year;<br>    cin &gt;&gt; year;<br>    cont &lt;&lt; <span class="hljs-string">&quot;What is its straat address?\n&quot;</span>;<br>    <span class="hljs-type">char</span> address[<span class="hljs-number">80</span>];<br>    cin.<span class="hljs-built_in">getline</span>(address, <span class="hljs-number">80</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Year built : &quot;</span>&lt;&lt; year &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address: &quot;</span> &lt;&lt; address &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Done!\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">What year was your house <span class="hljs-keyword">built?</span><br><span class="hljs-keyword"></span><span class="hljs-number">1966</span><br>What is its straat <span class="hljs-keyword">address?</span><br><span class="hljs-keyword"></span>Year <span class="hljs-keyword">built </span>: <span class="hljs-number">1966</span><br><span class="hljs-keyword">Address: </span><br>Done!<br></code></pre></td></tr></table></figure>

<p>问题：cin读取年份时，将回车键生成的换行符留在了输入队列中。后面的cin.getline()看到换行符后，将认为是一个空行，并将一个空字符串赋给address数组。解决方法是在读取address之前先读取并丢弃换行符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin &gt;&gt; year;<br>cin.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure>

<h4 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a>string 类</h4><p>string类型的变量（不是字符数组）来存储字符串</p>
<p>要使用string，必须在程序中包含头文件string。string类位于名称空间std中，因此要提供一条using编 译指令或者使用std::string来引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str1;<br>string str2 = <span class="hljs-string">&quot;panda&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>类设计让程序能够自动处理string的大小。</p>
<h5 id="赋值、拼接和附加"><a href="#赋值、拼接和附加" class="headerlink" title="赋值、拼接和附加"></a><strong>赋值、拼接和附加</strong></h5><p>可以将一个string对象赋给另一个string对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++\">string str1;<br>string str2 = &quot;panda&quot;;<br>str1 = str2;<br></code></pre></td></tr></table></figure>

<p>string类可以使用运算符+将两个string对象合并起来，还可以使用运算符+&#x3D;将字符串附加到string对象的末尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str3;<br>str3 = str1 +str2;<br>str1 += str2;<br></code></pre></td></tr></table></figure>

<p>对比字符数组操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">strcpy</span>(charr3, charr1);<span class="hljs-comment">// s2=s1</span><br><span class="hljs-built_in">strcat</span>(charr3, charr2);<span class="hljs-comment">// s3=s3+s2</span><br></code></pre></td></tr></table></figure>

<p>strlen()和size()功能基本相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> len1 = str1.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> len2 = <span class="hljs-built_in">strlen</span>(charr1);<br></code></pre></td></tr></table></figure>

<h5 id="string类I-x2F-O"><a href="#string类I-x2F-O" class="headerlink" title="string类I&#x2F;O"></a><strong>string类I&#x2F;O</strong></h5><p>当读取一个单词时，可以使用类似于c风格字符串的处理方式，用cin &lt;&lt; 来将输入存储到string对象；使用cout &gt;&gt; 来显示string对象。<strong>但每次读取一行而不是一个单词时，使用的语法不同。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">getline</span>(cin, str);<br></code></pre></td></tr></table></figure>



<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体是一种比数组更灵活的数据格式，因为同一个结构体可以存储多种类型的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">name</span><br>&#123;<br>	<span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>	<span class="hljs-type">float</span> volume;<br>	<span class="hljs-type">double</span> price;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">name</span> product_a;<span class="hljs-comment">//keyword struct  required in c</span><br>name product_b;<span class="hljs-comment">//keyword struct not required in c++</span><br></code></pre></td></tr></table></figure>

<p>使用成员运算符.来访问结构体成员，<code>product_a.name</code></p>
<p>根据需要，可以将结构体定义在全局或者函数内部。</p>
<p>结构体可以将string类作为成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inflatable</span><br>&#123;<br>	std::string name;<br>	<span class="hljs-type">float</span> volume;<br>	<span class="hljs-type">double</span> price;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以使用赋值运算符(&#x3D;)将结构体赋给另外一个同类型的结构体，这样结构中的每一个成员都被设置为另一个结构中相应成员的值，即使成员是数组，这种赋值称为成员赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inflatable</span><br>&#123;<br>	<span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>	<span class="hljs-type">float</span> volume;<br>	<span class="hljs-type">double</span> price;<br>&#125;<br>inflatable bouquet=<br>&#123;<br>    <span class="hljs-string">&quot;sunflowers&quot;</span>,<br>    <span class="hljs-number">0.20</span>,<br>    <span class="hljs-number">12.49</span><br>&#125;;<br>inflatable choice;<br>choice = bouquet;<br></code></pre></td></tr></table></figure>

<p><strong>结构数组</strong></p>
<p>创建元素为结构体的数组</p>
<p><code>inflatable gifts[100];</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin &gt;&gt; gifts[<span class="hljs-number">0</span>].volume;<br>cout &lt;&lt; gifts[<span class="hljs-number">99</span>].price &lt;&lt;endl;<br></code></pre></td></tr></table></figure>



<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体数一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。（结构体是和的关系，共用体是或的关系）。</p>
<p>共用体每次只能存储一个值（各种值共用一块内存），其长度为最大成员的长度。</p>
<p>共用体常用于节省内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">one4all</span><br>&#123;<br>	<span class="hljs-type">int</span> int_val;<br>	<span class="hljs-type">long</span> long_val;<br>	<span class="hljs-type">double</span> double_val;<br>&#125;<br>one4all pail;<br>pail.int_val = <span class="hljs-number">15</span>;<br>pail.double_val = <span class="hljs-number">1.38</span>;<br></code></pre></td></tr></table></figure>



<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>c++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const，还允许定义新类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">spectrum</span> &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>red、orange、yellow等作为符号常量，对应整数值0-7</p>
</li>
<li><p>枚举只定义了赋值运算符，没有定义算术运算</p>
</li>
<li><p>枚举可以被提升为int类型，但int类型不能自动转换为枚举类型</p>
</li>
<li><p>如果int值有效，则可以通过强制类型转换，将它赋给枚举类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">band = <span class="hljs-built_in">spectrum</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<p>枚举更常用来被定义相关的符号常量（red &#x3D; 0, orange &#x3D; 1, yellow &#x3D; 3……）</p>
<p>每个枚举都有取值范围，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，机制这个值不是枚举值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">bits</span> &#123;one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>, four = <span class="hljs-number">4</span>, eight = <span class="hljs-number">8</span>&#125;;<br>bits myflag;<br>myflag = <span class="hljs-built_in">bits</span>(<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure>

<p>取值范围的定义如下：首先找到上限，需要知道枚举量的最大值，找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。要计算下限，需要知道枚举量的最小值，如果它不小于0，则取值范围的下限为0,；否则与寻找上限方式相同的方式，但加上负号。</p>
<h3 id="指针与自由存储空间"><a href="#指针与自由存储空间" class="headerlink" title="指针与自由存储空间"></a>指针与自由存储空间</h3><p>指针是一个变量，存储的是值的地址，而不是值本身。查看常规变量的地址，使用地址运算符&amp;。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> updates = <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> * p_updates;<br>p_updates = &amp;updates;<br><span class="hljs-comment">//express values two ways</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Values:updates = &quot;</span> &lt;&lt; updates;<br>cout &lt;&lt; <span class="hljs-string">&quot;, *p_updates = &quot;</span> &lt;&lt; *p_updates &lt;&lt;endl;<br></code></pre></td></tr></table></figure>

<h4 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a><strong>使用new来分配内存</strong></h4><p>在c语言中，可以使用库函数malloc()来分配内存；在c++中仍可以这样做，但c++还有更好的方法——new运算符 。</p>
<p><code> typeName * pointer_name = new typeName</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * pn =<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br></code></pre></td></tr></table></figure>

<p>new分配的内存块通常与常规变量分配的内存块不同。常规变量存储在栈中，而new从北称为堆或自由存储区的内存区域分配内存。</p>
<h4 id="使用delete来释放内存"><a href="#使用delete来释放内存" class="headerlink" title="使用delete来释放内存"></a><strong>使用delete来释放内存</strong></h4><p>delete运算符使得在使用完内存后，能够将其归还给内存池。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * ps =<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>...<br><span class="hljs-keyword">delete</span> ps;<br></code></pre></td></tr></table></figure>

<p>不要尝试释放已经释放的内存块</p>
<p>new和delete要成对使用</p>
<h4 id="用new创建动态数组"><a href="#用new创建动态数组" class="headerlink" title="用new创建动态数组"></a><strong>用new创建动态数组</strong></h4><p>如果通过声明来创建数组，则在<u>程序被编译时将为它分配内存空间</u>，不管程序最终是否使用数组，数组都在那里，它占用了内存。在编译时给数组分配内存被称为静态联编，意味着数组是在编译时加入到程序中的。</p>
<p>使用new时，如果在运行阶段需要数组，则创建它；如果不需要，则不创建。还可以<u>在程序运行时选择数组的长度</u>，这被称为动态联编，意味着数组是在程序运行时创建的，这种数组叫做动态数组。</p>
<p>使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。</p>
<p><code> type_name * poiinter_name = new type_name [num_elements]</code></p>
<p>new运算符返回第一个元素的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * psome = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [<span class="hljs-number">10</span>];<br>...<br><span class="hljs-keyword">delete</span> [] psome;<br></code></pre></td></tr></table></figure>

<p>访问动态数组元素：只要把指针当做数组名使用即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>	<span class="hljs-type">double</span> * p3 = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span> [<span class="hljs-number">3</span>];<br>	p3[<span class="hljs-number">0</span>] = <span class="hljs-number">0.2</span>;<br>	p3[<span class="hljs-number">1</span>] = <span class="hljs-number">0.5</span>;<br>	p3[<span class="hljs-number">2</span>] = <span class="hljs-number">0.8</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p3[1] is &quot;</span> &lt;&lt; p3[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>	p3 = p3 + <span class="hljs-number">1</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Now p3[0] is &quot;</span> &lt;&lt; p3[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> [] p3;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="指针、数组和指针算术"><a href="#指针、数组和指针算术" class="headerlink" title="指针、数组和指针算术"></a>指针、数组和指针算术</h3><p>指针与数组名：指针是变量，其值可以被修改，而数组名是常量。对数组应用sizeof运算符得到的是数组的长度（这种情况下，c++不会将数组名解释为地址），而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。</p>
<p>在多数情况下，数组名等于数组第一个元素的地址（sizeof除外），而对<strong>数组名应用地址运算符时，得到的是整个数组的地址。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">short</span> tell [<span class="hljs-number">10</span>];<br>cout &lt;&lt; tell &lt;&lt; endl;<br>cout &lt;&lt; &amp;tell &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>从数字上说，这两个地址相同；但是从概念上说，&amp;tell[0]（即tell）是一个2字节内存块的地址，，而&amp;tell时一个20字节内存块的地址。因此，表达式tell+1将地址值加2，而表达式&amp;tell+1将地址加20。（步长改变）</p>
<p>数组指针和指针数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//指针数组，</span><br><span class="hljs-comment">// pos先与[20]结合，pos是一个数组，每一个元素是short*类型（指向short类型值的指针）</span><br><span class="hljs-type">short</span> *pos[<span class="hljs-number">20</span>];<br><br><span class="hljs-comment">//数组指针</span><br><span class="hljs-comment">// pos先与*结合，pos是一个指针，指向一个数组，数组有20个元素，每一个元素时short类型</span><br><span class="hljs-built_in">short</span> (*pos)[<span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure>

<h4 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h4><p>如果给cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。如果想要打印地址，进行强制类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> animals[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;tigger&quot;</span>;<br>cout &lt;&lt; animals &lt;&lt; <span class="hljs-string">&quot;at&quot;</span> &lt;&lt; (<span class="hljs-type">int</span> *)animals &lt;&lt; endl;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>在cout和多数c++表达式中，char数组名、char指针以及用引号括起来的字符串常量都被解释为字符串的第一个字符的地址。</p>
</blockquote>
<blockquote>
<p>常量指针（const）：指针的指向可以修改，但是指针指向的值不可以改</p>
</blockquote>
<h4 id="使用new创建动态结构体"><a href="#使用new创建动态结构体" class="headerlink" title="使用new创建动态结构体"></a>使用new创建动态结构体</h4><p>在程序运行时（而非编译时）为结构体分配所需的空间</p>
<p><code> inflatable * ps = new inflatable //inflatable 是自定义的结构体</code></p>
<p>访问结构体成员的两种方式：</p>
<ol>
<li><p>箭头成员运算符（-&gt;）:如果ps指向一个inflatable结构体，则ps-&gt;price是被指向的结构体的price成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">things</span><br>&#123;<br>	<span class="hljs-type">int</span> good;<br>	<span class="hljs-type">int</span> bad;<br>&#125;;<br>things grubnose = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">453</span>&#125;;<br>things *pt = &amp;grubnose;<br>cout &lt;&lt; grubnose.good &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; grubnose.bad &lt;&lt;endl;<br>cout &lt;&lt; pt-&gt;good &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; pt-&gt;bad &lt;&lt;endl;<br></code></pre></td></tr></table></figure>


</li>
<li><p>如果ps是指向结构体的指针，则*ps就是被指向的值（结构体本身），( *ps).price是该结构的price成员。</p>
</li>
</ol>
<h4 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h4><p><strong>自动存储</strong></p>
<p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。</p>
<p>自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。</p>
<p>自动变量通常存储在栈中。</p>
<p><strong>静态存储</strong></p>
<p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static。</p>
<p><strong>动态存储</strong></p>
<p>new和delete运算符提供了一种比自动变量和静态变量更灵活的方法，它们管理了一个内存池，在c++中被称为堆。数据的生命周期不完全受程序或函数的生存时间控制。</p>
<h3 id="数组的替代品"><a href="#数组的替代品" class="headerlink" title="数组的替代品"></a>数组的替代品</h3><h4 id="模板类vector"><a href="#模板类vector" class="headerlink" title="模板类vector"></a>模板类vector</h4><p><strong>动态数组</strong></p>
<p>是使用new创建动态数组的替代品</p>
<p>要点</p>
<ul>
<li>要使用vector对象，必须包含头文件vector</li>
<li>vector包含在名称空间std中，因此可使用using编译指令、using声明或std::vector</li>
<li>模板使用不同的语法来指出它存储的数据类型</li>
<li>vector类使用不同的语法来指定元素数</li>
</ul>
<p><code> vector &lt;typeName&gt; vt(n_elem)</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br>...<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std<br>vector &lt;<span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br>vector &lt;<span class="hljs-type">double</span>&gt; <span class="hljs-built_in">vd</span>(n);<br></code></pre></td></tr></table></figure>

<h4 id="模板类array"><a href="#模板类array" class="headerlink" title="模板类array"></a>模板类array</h4><p>功能强大但效率较低</p>
<p>位于名称空间std中，要创建array对象，需要包含头文件array</p>
<p>array对象的<strong>长度是固定</strong>的（和数组一样），也使用栈，相比于数组，其更方便更安全。</p>
<p><code>arryy&lt;typeName,n_elem&gt; arr</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;array&gt;</span></span><br>...<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>array&lt;<span class="hljs-type">int</span>, 5&gt; ai;<br>array&lt;<span class="hljs-type">double</span>, 4&gt; ad = &#123;<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">5.6</span>, <span class="hljs-number">7.3</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>可以将一个array对象赋给另一个array对象</p>
<p>c++不检查数组的越界错误，可以使用vector和array的成员函数at()在程序运行期间捕获非法索引，而程序默认将中断，这种额外检查的代价是运行时间更长。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">vector &lt;double&gt; <span class="hljs-built_in">a2</span>(<span class="hljs-number">4</span>);<br>a2<span class="hljs-selector-class">.at</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/c/">c++</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/c/">c++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/11/c++/c-4/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">c++基础知识(4)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/11/c++/c-2/">
                        <span class="hidden-mobile">c++基础知识(2)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
